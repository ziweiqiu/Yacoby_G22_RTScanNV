import numpy as np
import time
from pylabcontrol.core import Script, Parameter
# from b26_toolkit.instruments import L607RT_TDC001_magnetX, L607RT_TDC001_magnetY, L607RT_TDC001_magnetZ, R8SMicrowaveGenerator
from b26_toolkit.instruments import MagnetX, MagnetY, MagnetZ, R8SMicrowaveGenerator, Agilent33120A
from b26_toolkit.instruments import NI6353
from b26_toolkit.scripts.find_nv import FindNV
from .set_laser import SetLaser
from b26_toolkit.scripts.daq_read_counter import Daq_Read_Counter
from b26_toolkit.scripts.esr_RnS import ESR_FastSwp_RnS_FitGuaranteed, ESR_FastSwp_RnS
from b26_toolkit.scripts.pulse_sequences.rabi import Rabi_N9310A, Ramsey_N9310A
from b26_toolkit.scripts.pulse_sequences.hahn_echo import PDD_XYreadout, eSensing_swpV, eSensing_N9310A
from b26_toolkit.scripts.read_power import IntensityWheel_Calibration
# from b26_toolkit.scripts.daq_read_ai import Daq_Read_AI
from b26_toolkit.scripts.autofocus import AutoFocusDAQ
from b26_toolkit.scripts.optimize import optimize
from b26_toolkit.plotting.plots_1d import plot_counts_vs_pos, update_counts_vs_pos, plot_magnet_sweep1D_ESR, plot_magnet_sweep1D_Fluor
from b26_toolkit.plotting.plots_2d import plot_magnet_sweep2D_Fluor, update_magnet_sweep2D_Fluor
from collections import deque
import scipy as sp
from b26_toolkit.plotting.plots_2d import plot_fluorescence_pos, update_fluorescence

class MagnetSweep(Script):
    """
    MagnetSweep sweeps the position of the automatic translation stages, in 1D scans, and records NV fluorescence
    using Daq_Read_Counter and/or measure the ESR of NV, at each point in the scan.
    We use the NV fluorescence to align a magnetic bias field to the NV axis, generated by a permanent magnet.
    ER 20180606
    --> Last edited by ZQ 3/3/2019
    """

    _DEFAULT_SETTINGS = [
        Parameter('servo_initial', [Parameter('initialize', True, bool, 'whether or not intialize the servo position before sweeping? (this is recommended for servo reproducibility)'),
                                    Parameter('Xservo', 0.0, float, 'initial position of Xservo'),
                                    Parameter('Yservo', 0.0, float, 'initial position of Yservo'),
                                    Parameter('Zservo', 24.0, float, 'initial position of Zservo'),
                                    Parameter('moving_velocity', 0.5, float, 'servo moving velocity (mm/s)')]),
        Parameter('sweep_settings', [Parameter('scan_axis', 'y', ['x', 'y', 'z'], 'axis to scan on'),
                                     Parameter('num_points', 16, int, 'number of points in the scan'),
                                     Parameter('min_pos', 0., float, 'minimum position of scan (mm)'),
                                     Parameter('max_pos', 5., float, 'maximum position of scan (mm)'),
                                     Parameter('moving_velocity', 0.5, float, 'servo moving velocity (mm/s)')]),
        Parameter('exp_to_do', [Parameter('fluorescence', True, bool, 'measure the NV fluorescence'),
                                Parameter('esr', True, bool, 'measure the ESR of NV'),
                                Parameter('esr2', True, bool,
                                          'measure the ESR of NV at two different frequencies')]),
        Parameter('exp_settings', [
            Parameter('fluorescence_time_per_pt', 0.4, float, 'time for fluorescence measurement at each point (s)'),
            Parameter('esr_mw_pwr', -10, float, 'microwave power for ESR scan'),
            Parameter('esr_avg', 22, int, 'number of esr averages'),
            Parameter('esr_cntr_freq', 2.82e9, float, 'center frequency for ESR scan'),
            Parameter('esr_freq_range', 4.0e7, float, 'frequency range for ESR scan (suggest 4.0e7)'),
            Parameter('esr2_cntr_freq', 2.92e9, float, 'center frequency for the second ESR scan'),
            Parameter('esr2_freq_range', 4.0e7, float, 'frequency range for the second ESR scan (suggest 4.0e7)'),
            Parameter('esr_num_of_pts', 60, int, 'number of frequency points for ESR scan'),
            Parameter('esr_time_per_pt', 0.02, [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1], 'integration time for each point in the fast ESR scan (suggest 0.02)'),
            Parameter('esrfit_minimum_counts', 0.8, float, 'minumum counts for an ESR to not be considered noise (suggest 0.8)'),
            Parameter('esrfit_contrast_factor', 4.0, float, 'minimum contrast for an ESR to not be considered noise (suggest 4.0)')
        ]),
        Parameter('tracking_settings', [Parameter('track_focus', 'None', ['optimize_z', 'autofocus', 'None'],
                                                  'choose the method for tracking (optimize_z is recommended)'),
                                        Parameter('track_focus_every_N', 10, int, 'track every N points'),
                                        Parameter('track_to_nv', False, bool,
                                                  'check to use find_nv to track to the NV'),
                                        Parameter('track_to_nv_every_N', 10, int, 'track every N points'),
                                        Parameter('track_frequency', True, bool,
                                                  'keep track of the frequency and set it to the central frequency of the next ESR scan'),
                                        Parameter('track_frequency_every_N', 1, int, 'track every N points')]),
        Parameter('optimize_z_settings', [Parameter('sweep_range', 0.6, float, 'z voltage range for optimizing scan (suggest 0.6)'),
                                         Parameter('num_points', 41, float, 'number of z points to scan (suggest 41)'),
                                        ]),
        Parameter('autofocus_settings', [Parameter('scan_width', 0.8, float, 'z voltage range for optimizing scan (suggest 0.6 - 1)'),
                                         Parameter('num_sweep_points', 10, int,
                                                   'number of values to sweep between min and max voltage (suggest 10)'),
                                          ]),
        Parameter('find_nv_settings', [Parameter('sweep_range', 0.4, float, 'voltage range to sweep over to find a max (suggest 0.4)'),
                                       Parameter('num_points', 61, int, 'number of points to sweep in the sweep range (suggest 61)'),
                                       Parameter('nv_size', 21, int,'size of nv in pixels - need to be refined!! needs to be odd number!!! (suggest 21)'),
                                       Parameter('min_mass', 80, int, 'TEMP: brightness of nv - need to be refined!! (suggest 60-90)'),
                                          ])
        ]

    # _INSTRUMENTS = {'XServo': L607RT_TDC001_magnetX, 'YServo': L607RT_TDC001_magnetY, 'ZServo': L607RT_TDC001_magnetZ, 'mw_gen': R8SMicrowaveGenerator}
    _INSTRUMENTS = {'XServo': MagnetX, 'YServo': MagnetY, 'ZServo': MagnetZ,
                    'mw_gen': R8SMicrowaveGenerator}

    _SCRIPTS = {'find_nv': FindNV, 'daq_read_counter': Daq_Read_Counter, 'esr': ESR_FastSwp_RnS, 'autofocus': AutoFocusDAQ, 'optimize_z': optimize}

    def __init__(self, instruments = None, scripts = None, name = None, settings = None, log_function = None, data_path = None):
        """
        Example of a script that makes use of an instrument
        Args:
            instruments: instruments the script will make use of
            name (optional): name of script, if empty same as class name
            settings (optional): settings for this script, if empty same as default settings
        """

        # call init of superclass
        Script.__init__(self, name, settings=settings, instruments=instruments, scripts=scripts,
                        log_function=log_function, data_path=data_path)

    def _get_instr(self):
        """
        Assigns an instrument relevant to the 1D scan axis.
        """
        if self.settings['sweep_settings']['scan_axis'] == 'x':
            return self.instruments['XServo']['instance']
        elif self.settings['sweep_settings']['scan_axis'] == 'y':
            return self.instruments['YServo']['instance']
        elif self.settings['sweep_settings']['scan_axis'] == 'z':
            return self.instruments['ZServo']['instance']

    def _get_scan_positions(self, verbose=True):
        '''
        Returns an array of points to go to in the 1D scan.
        '''
        if self.settings['sweep_settings']['scan_axis'] in ['x', 'y', 'z']:
            scan_pos = [
                np.linspace(self.settings['sweep_settings']['min_pos'], self.settings['sweep_settings']['max_pos'],
                            self.settings['sweep_settings']['num_points'])]
            if verbose:
                print('values for the scan are (in mm):', scan_pos)
            return scan_pos
        else:
            print('NotImplementedError: multiple dimensional scans not yet implemented')
            NotImplementedError('multiple dimensional scans not yet implemented')

    def gaussian(self, x, noise, amp, center, width):
        return (noise + amp * np.exp(-1.0 * (np.square((x - center)) / (2 * (width ** 2)))))

    def fit_gaussian(self):
        noise_guess = np.min(self.data['counts'])
        amplitude_guess = np.max(self.data['counts']) - noise_guess
        center_guess = np.mean(self.data['positions'])
        width_guess = np.std(self.data['positions'])

        p2 = [noise_guess, amplitude_guess, center_guess, width_guess]

        pos_of_max = None
        print('trying to fit the gaussian!')
        try:
            p2, success = sp.optimize.curve_fit(self.gaussian, self.data['positions'],
                                                self.data['counts'], p0=p2,
                                                bounds=([0, [np.inf, np.inf, 100., 100.]]), max_nfev=2000)

            print('p2', p2)
            print('success', success)

            pos_of_max = p2[2]

            self.log('Found fit parameters: ' + str(p2))
        except(ValueError, RuntimeError):
            self.log('Could not converge to fit parameters')

        return pos_of_max, p2

    def meas_fluorescence(self):
        # run daq_read_counter or the relevant script to get fluorescence
        print('==> Start measuring FLUORESCENCE...')
        self.scripts['daq_read_counter'].run()
        time.sleep(self.settings['exp_settings']['fluorescence_time_per_pt'])
        self.scripts['daq_read_counter'].stop()
        data = self.scripts['daq_read_counter'].data['counts']
        return data

    def do_esr(self, esr_cntr_freq, esr_freq_range, verbose = False ):
        # set the right parameters for the esr scan
        self.scripts['esr'].settings['power_out'] = self.settings['exp_settings']['esr_mw_pwr']
        self.scripts['esr'].settings['esr_avg'] = self.settings['exp_settings']['esr_avg']
        self.scripts['esr'].settings['freq_start'] = float(esr_cntr_freq)
        self.scripts['esr'].settings['freq_stop'] = float(esr_freq_range)
        self.scripts['esr'].settings['range_type'] = 'center_range'
        self.scripts['esr'].settings['freq_points'] = self.settings['exp_settings']['esr_num_of_pts']
        self.scripts['esr'].settings['time_per_pt'] = self.settings['exp_settings']['esr_time_per_pt']
        self.scripts['esr'].settings['fit_constants']['minimum_counts'] = self.settings['exp_settings'][
            'esrfit_minimum_counts']
        self.scripts['esr'].settings['fit_constants']['contrast_factor'] = self.settings['exp_settings'][
            'esrfit_contrast_factor']
        print('==> Start measuring ESR...')
        self.scripts['esr'].run()
        esr_fit_data = self.scripts['esr'].data['fit_params']
        if verbose == True:
            print('len(esr_fit_data) =  ', esr_fit_data)

        return esr_fit_data

    def _function(self):

        # initialize the servo positions
        if self.settings['servo_initial']['initialize']:
            print('----------- Servo Initialization -----------')
            self.instruments['XServo']['instance'].update({'velocity': self.settings['servo_initial']['moving_velocity']})
            self.instruments['YServo']['instance'].update({'velocity': self.settings['servo_initial']['moving_velocity']})
            self.instruments['ZServo']['instance'].update({'velocity': self.settings['servo_initial']['moving_velocity']})
            self.instruments['XServo']['instance'].update({'position': self.settings['servo_initial']['Xservo']})
            self.instruments['YServo']['instance'].update({'position': self.settings['servo_initial']['Yservo']})
            self.instruments['ZServo']['instance'].update({'position': self.settings['servo_initial']['Zservo']})

        # get the relevant instrument for controlling the magnet.
        scan_instr = self._get_instr()
        # scan_instr.settings['velocity'] = self.settings['sweep_settings']['moving_velocity']
        # scan_instr._connect()
        scan_instr.update({'velocity': self.settings['sweep_settings']['moving_velocity']})

        # get positions for the scan.
        scan_pos = self._get_scan_positions()

        # set the parameters for all the scripts
        # optimize_z settings
        self.scripts['optimize_z'].update({'optimizing_x': False})
        self.scripts['optimize_z'].update({'optimizing_y': False})
        self.scripts['optimize_z'].update({'optimizing_z': True})
        self.scripts['optimize_z'].settings['sweep_range'].update(
            {'z': self.settings['optimize_z_settings']['sweep_range']})
        self.scripts['optimize_z'].settings['num_points'].update(
            {'z': self.settings['optimize_z_settings']['num_points']})
        # find_nv settings
        self.scripts['find_nv'].update({'center_on_current_location': True})
        self.scripts['find_nv'].update({'sweep_range': self.settings['find_nv_settings']['sweep_range']})
        self.scripts['find_nv'].update({'num_points': self.settings['find_nv_settings']['num_points']})
        self.scripts['find_nv'].update({'nv_size': self.settings['find_nv_settings']['nv_size']})
        self.scripts['find_nv'].update({'min_mass': self.settings['find_nv_settings']['min_mass']})
        # autofocus settings
        self.scripts['autofocus'].update({'scan_width': self.settings['autofocus_settings']['scan_width']})
        self.scripts['autofocus'].update({'num_sweep_points': self.settings['autofocus_settings']['num_sweep_points']})
        self.scripts['autofocus'].scripts['take_image'].settings['num_points'].update({'x': 51})
        self.scripts['autofocus'].scripts['take_image'].settings['num_points'].update({'y': 51})


        # data structure
        self.data = {'counts': deque(),'esr_fo': deque(), 'esr_wo': deque(),'esr2_fo': deque(), 'esr2_wo': deque()}
        self.positions = {'positions': deque()}

        # place for fit parameters
        # self.data['fit_parameters'] = [0, 0, 0, 0]
        self.data['positions'] = scan_pos
        # self.data['counts'] = np.zeros(len(scan_pos))
        # self.data['esr_fo'] = np.zeros(len(scan_pos))
        # self.data['esr_wo'] = np.zeros(len(scan_pos))
        # self.data['esr2_fo'] = np.zeros(len(scan_pos))
        # self.data['esr2_wo'] = np.zeros(len(scan_pos))

        self.current_esr_cntr_freq = self.settings['exp_settings']['esr_cntr_freq']
        self.current_esr2_cntr_freq = self.settings['exp_settings']['esr2_cntr_freq']
        self.esr_cntr_freq_todo = self.current_esr_cntr_freq
        self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

        # loop over scan positions and call the scripts
        for index in range(0, self.settings['sweep_settings']['num_points']):

            if self._abort:
                break
            new_pos = float(scan_pos[0][index])
            print('================== Start (index = ' + str(index) + ') ======================')
            print('----------- Magnet Position: {:0.2f} mm -----------'.format(new_pos))
            # scan_instr.settings['position'] = new_pos # update the position setting of the instrument
            # scan_instr.set_position() # actually move the instrument to that location. If this is not within the safety
            #                           # limits of the instruments, it will not actually move and say so in the log
            scan_instr.update({'position': new_pos})

            print('---------------- Tracking ----------------')
            # track to the NV if it's time to
            if self.settings['tracking_settings']['track_focus'] != 'None':
                if index > 0 and index % self.settings['tracking_settings']['track_focus_every_N'] == 0:
                    print('==> Do track_focus now:')
                    if self.settings['tracking_settings']['track_focus'] == 'optimize_z':
                        print('    ==> optimize_z starts')
                        self.scripts['optimize_z'].run()

                        self.flag_find_nv_plot = True
                        print('==> find_NV starts (after tracking focus)')
                        self.scripts['find_nv'].run()

                    elif self.settings['tracking_settings']['track_focus'] == 'autofocus':
                        print('    ==> autofocus starts')
                        self.flag_autofocus_plot = True
                        self.scripts['autofocus'].run()

                        print('==> find_NV starts (after tracking focus)')
                        self.flag_find_nv_plot = True
                        self.scripts['find_nv'].run()

            if self.settings['tracking_settings']['track_to_nv']:
                # print('check if it is time to do find_nv?')
                # print('mod is ', index % self.settings['tracking_settings']['track_to_nv_every_N'])
                # if index > 0 and index % self.settings['tracking_settings']['track_to_nv_every_N'] == 0 & index % self.settings['tracking_settings']['track_focus_every_N'] != 0:
                if index > 0 and index % self.settings['tracking_settings']['track_to_nv_every_N'] == 0:
                    self.flag_find_nv_plot = True
                    print('==> find_NV starts')
                    self.scripts['find_nv'].run()
            if self.settings['tracking_settings']['track_frequency']:
                if index > 0 and index % self.settings['tracking_settings']['track_frequency_every_N'] == 0:
                    print('==> track_frequency')
                    self.esr_cntr_freq_todo = self.current_esr_cntr_freq
                    self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

            print('---------------- Experiment ----------------')
            # Do the actual measurements
            if self.settings['exp_to_do']['fluorescence']:
                fluor_data = self.meas_fluorescence()
                # add to output structures which will be plotted
                self.data['counts'].append(np.mean(fluor_data))
            if self.settings['exp_to_do']['esr']:
                esr_fit_data = self.do_esr(self.esr_cntr_freq_todo, self.settings['exp_settings']['esr_freq_range'])

                if esr_fit_data is None:
                    print('--> No ESR fitting')
                    # add to output structures which will be plotted
                    self.data['esr_fo'].append(0.0)
                    self.data['esr_wo'].append(0.0)
                    # # update the ESR center frequency
                    # self.current_esr_cntr_freq = self.settings['exp_settings']['esr_cntr_freq']
                elif len(esr_fit_data) == 4:
                    if esr_fit_data[3] < 0.5e6:
                        self.data['esr_fo'].append(0.0)
                        self.data['esr_wo'].append(0.0)
                        print('--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                    else:
                        print('--> Good, find one ESR peak :). fo = ' + str(esr_fit_data[2]) + ' Hz, wo = ' + str(
                            esr_fit_data[3]) + 'Hz')
                        # add to output structures which will be plotted
                        self.data['esr_fo'].append(esr_fit_data[2])
                        self.data['esr_wo'].append(esr_fit_data[3])
                        # update the ESR center frequency
                        self.current_esr_cntr_freq = esr_fit_data[2]

                elif len(esr_fit_data) == 6:
                    if esr_fit_data[1] < 0.5e6:
                        self.data['esr_fo'].append(0.0)
                        self.data['esr_wo'].append(0.0)
                        print(
                            '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                    else:
                        print('--> Find two ESR peaks, only record the first peak info')
                        # add to output structures which will be plotted
                        self.data['esr_fo'].append(esr_fit_data[4])
                        self.data['esr_wo'].append(esr_fit_data[1])
                        # update the ESR center frequency
                        self.current_esr_cntr_freq = esr_fit_data[4]
            if self.settings['exp_to_do']['esr2']:
                esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo, self.settings['exp_settings']['esr2_freq_range'])
                if esr2_fit_data is None:
                    print('--> No ESR2 fitting')
                    # add to output structures which will be plotted
                    self.data['esr2_fo'].append(0.0)
                    self.data['esr2_wo'].append(0.0)
                    # # update the ESR2 center frequency
                    # self.current_esr2_cntr_freq = self.settings['exp_settings']['esr2_cntr_freq']
                elif len(esr2_fit_data) == 4:
                    if esr2_fit_data[3] < 0.5e6:
                        self.data['esr2_fo'].append(0.0)
                        self.data['esr2_wo'].append(0.0)
                        print('--> Find one ESR2 peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                    else:
                        print('--> Good, find one ESR2 peak :). fo = ' + str(esr2_fit_data[2]) + ' Hz, wo = ' + str(esr2_fit_data[3]) + 'Hz')
                        # add to output structures which will be plotted
                        self.data['esr2_fo'].append(esr2_fit_data[2])
                        self.data['esr2_wo'].append(esr2_fit_data[3])
                        # update the ESR2 center frequency
                        self.current_esr2_cntr_freq = esr2_fit_data[2]
                elif len(esr2_fit_data) == 6:
                    if esr2_fit_data[1] < 0.5e6:
                        self.data['esr2_fo'].append(0.0)
                        self.data['esr2_wo'].append(0.0)
                        print(
                            '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                    else:
                        print('--> Find two ESR2 peaks, only record the first peak info')
                        # add to output structures which will be plotted
                        self.data['esr2_fo'].append(esr2_fit_data[4])
                        self.data['esr2_wo'].append(esr2_fit_data[1])
                        # update the ESR2 center frequency
                        self.current_esr2_cntr_freq = esr2_fit_data[4]

            print('======================= Finished ===========================')

            # record the position
            self.positions['positions'].append(new_pos)
            self.progress = index*100./self.settings['sweep_settings']['num_points']
            self.updateProgress.emit(int(self.progress))

        # scan_instr.__del__()

        # clean up data, as in daq_read_counter
        if 'counts' in self.data.keys() is not None:
            self.data['counts'] = list(self.data['counts'])
        if 'esr_fo' in self.data.keys() is not None:
            self.data['esr_fo'] = list(self.data['esr_fo'])
        if 'esr_wo' in self.data.keys() is not None:
            self.data['esr_wo'] = list(self.data['esr_wo'])
        if 'esr2_fo' in self.data.keys() is not None:
            self.data['esr2_fo'] = list(self.data['esr2_fo'])
        if 'esr2_wo' in self.data.keys() is not None:
            self.data['esr2_wo'] = list(self.data['esr2_wo'])

        # attempt to fit
        # pos_of_max, self.data['fit_parameters'] = self.fit_gaussian()
        # if pos_of_max:
        #     print('found maximum fluorescence position at: ', pos_of_max, ' mm')
        # todo: need to implement tracking and plotting

    def _plot(self, axes_list, data = None):
        # COMMENT_ME

        if data is None:
            data = self.data

        if self._current_subscript_stage['current_subscript'] is self.scripts['esr'] and self.scripts['esr'].is_running:
            self.scripts['esr']._plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['daq_read_counter'] and self.scripts['daq_read_counter'].is_running:
            self.scripts['daq_read_counter']._plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['find_nv'] and self.scripts['find_nv'].is_running:
            self.scripts['find_nv']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['optimize_z'] and self.scripts['optimize_z'].is_running:
            self.scripts['optimize_z']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['autofocus'] and self.scripts['autofocus'].is_running:
            self.scripts['autofocus']._update_plot([axes_list[0], axes_list[1]])

        else:
            print('(plot)')

            if self.data['counts'] is not None:
                lbls1 = ['magnet position ' + self.settings['sweep_settings']['scan_axis'] + ' [mm]', 'counts [kcps]', 'Fluorescence']
                plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['positions'][0], np.array(self.data['counts']),lbls1)
            if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                lbls2 = ['magnet position ' + self.settings['sweep_settings']['scan_axis'] + ' [mm]', 'f0 [Hz]', 'wo[Hz]', 'ESR']
                plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'][0], np.array(self.data['esr_fo']),
                                        np.array(self.data['esr_wo']), lbls2)
            if self.data['esr2_fo'] is not None and self.data['esr2_wo'] is not None:
                lbls3 = ['magnet position ' + self.settings['sweep_settings']['scan_axis'] + ' [mm]', 'f0 [Hz]', 'wo[Hz]', 'ESR 2']
                plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'][0], np.array(self.data['esr2_fo']),
                                        np.array(self.data['esr2_wo']), lbls3)
            else:
                print('Unfortunately, no data to plot :(...')

        # if data:
        #     plot_counts_vs_pos(axes_list[0], data['counts'], self.positions['positions'])
        #
        # # if the fit has finished plot the result
        # if not (np.array_equal(data['fit_parameters'], [0, 0, 0, 0])):
        #     axes_list[0].plot(data['positions'],
        #                     self.gaussian(data['positions'], *self.data['fit_parameters']), 'k')

    def _update_plot(self, axes_list):
        # update_counts_vs_pos(axes_list[0], self.data['counts'], self.positions['positions'])
        if self._current_subscript_stage['current_subscript'] is self.scripts['daq_read_counter'] and self.scripts['daq_read_counter'].is_running:
            self.scripts['daq_read_counter']._plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['esr'] and self.scripts['esr'].is_running:
            self.scripts['esr']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['find_nv'] and self.scripts['find_nv'].is_running:
            if self.flag_find_nv_plot:
                # print('self.flag_find_nv_plot is', self.flag_find_nv_plot)
                self.scripts['find_nv']._plot([axes_list[1]], colorbar=0) # this is to remove colorbar
                self.flag_find_nv_plot = False
            else:
                self.scripts['find_nv']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['optimize_z'] and self.scripts['optimize_z'].is_running:
            # print('optimize_z is running, update plot')
            self.scripts['optimize_z']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['autofocus'] and self.scripts['autofocus'].is_running:
            # print('autofocus is running, update plot')
            if self.flag_autofocus_plot:
                # print('self.flag_autofocus_plot is', self.flag_autofocus_plot)
                self.scripts['autofocus']._plot([axes_list[0], axes_list[1]], colorbar=0)
                self.flag_autofocus_plot = False
            else:
                self.scripts['autofocus']._update_plot([axes_list[0], axes_list[1]])
        else:
            print('(updating plot)')
            if self.data['counts'] is not None:
                lbls1 = ['magnet position ' + self.settings['sweep_settings']['scan_axis'] + ' [mm]', 'counts [kcps]', 'Fluorescence']
                plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['positions'][0], np.array(self.data['counts']), lbls1)
            if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                lbls2 = ['magnet position ' + self.settings['sweep_settings']['scan_axis'] + ' [mm]', 'f0 [Hz]', 'wo[Hz]', 'ESR']
                plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'][0], np.array(self.data['esr_fo']),
                                        np.array(self.data['esr_wo']), lbls2)
            if self.data['esr2_fo'] is not None and self.data['esr2_wo'] is not None:
                lbls3 = ['magnet position ' + self.settings['sweep_settings']['scan_axis'] + ' [mm]', 'f0 [Hz]', 'wo[Hz]', 'ESR 2']
                plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'][0], np.array(self.data['esr2_fo']),
                                        np.array(self.data['esr2_wo']), lbls3)
            else:
                print('Unfortunately, no data to update the plot :(...')

    def get_axes_layout(self, figure_list):
        """
        returns the axes objects the script needs to plot its data
        this overwrites the default get_axis_layout in PyLabControl.src.core.scripts
        Args:
            figure_list: a list of figure objects
        Returns:
            axes_list: a list of axes objects

        """
        axes_list = []
        if self._plot_refresh is True:
            # print('self._plot_refresh', self._plot_refresh)
            for fig in figure_list:
                fig.clf()

            # axes_list.append(figure_list[0].add_subplot(121))
            # axes_list.append(figure_list[0].add_subplot(122))

            # 5 subplots in total
            axes_list.append(figure_list[0].add_subplot(131))# axes_list[0]
            axes_list.append(figure_list[1].add_subplot(111))# axes_list[1]
            axes_list.append(figure_list[0].add_subplot(232))# axes_list[2]
            axes_list.append(figure_list[0].add_subplot(235))# axes_list[3]
            axes_list.append(figure_list[0].add_subplot(233))# axes_list[4]
            axes_list.append(figure_list[0].add_subplot(236))# axes_list[5]

        else:
            axes_list.append(figure_list[0].axes[0])
            axes_list.append(figure_list[1].axes[0])
            axes_list.append(figure_list[0].axes[1])
            axes_list.append(figure_list[0].axes[2])
            axes_list.append(figure_list[0].axes[3])
            axes_list.append(figure_list[0].axes[4])

        return axes_list

class MagnetSweep2D(Script):
    """
        MagnetSweep2D sweeps the position of the automatic translation stages, in 1D or 2D scans, and records NV fluorescence using Daq_Read_Counter and/or measure the ESR of NV, at each point in the scan.
        --> Last edited by ZQ 3/15/2019
    """

    _DEFAULT_SETTINGS = [
        Parameter('to-do', 'sweep', ['initialize', 'move', 'sweep', 'read'], 'Choose to move to a point, do a magnet sweep or just read the magnet positions'),
        Parameter('servo_initial',
                  [Parameter('initialize', True, bool,
                             'whether or not to intialize the servo position before sweeping? (highly recommended)'),
                   Parameter('Xservo', 9.0, float, 'initial position of Xservo'),
                   Parameter('Yservo', 4.0, float, 'initial position of Yservo'),
                   Parameter('Zservo', 5.0, float, 'initial position of Zservo'),
                   Parameter('moving_velocity', 0.5, float, 'servo moving velocity (mm/s)'),
                   Parameter('Xservo_min', 0.0, float, 'minimum allowed position of Xservo'),
                   Parameter('Xservo_max', 23.0, float, 'maximum allowed position of Xservo'),
                   Parameter('Yservo_min', 0.0, float, 'minimum allowed position of Yservo'),
                   Parameter('Yservo_max', 13.0, float, 'maximum allowed position of Yservo'),
                   Parameter('Zservo_min', 0.0, float, 'minimum allowed position of Zservo'),
                   Parameter('Zservo_max', 25.0, float, 'maximum allowed position of Zservo'),
                   ]),

        Parameter('scan_axis', 'xy', ['xy', 'yx', 'xz', 'zx', 'yz', 'zy', 'x', 'y', 'z'],
                  'Choose 2D or 1D magnet sweep to perform'),
        Parameter('move_to',
                  [Parameter('x', 15.0, float, 'move to x-coordinate [mm]'),
                   Parameter('y', 10.0, float, 'move to y-coordinate [mm]'),
                   Parameter('z', 10.0, float, 'move to z-coordinate [mm]')
                   ]),
        Parameter('sweep_center',
                  [Parameter('x', 15.0, float, 'x-coordinate [mm] of the sweep center'),
                   Parameter('y', 10.0, float, 'y-coordinate [mm] of the sweep center'),
                   Parameter('z', 5.0, float, 'z-coordinate [mm] of the sweep center')
                   ]),
        Parameter('sweep_span',
                  [Parameter('x', 10.0, float, 'x-coordinate [mm]'),
                   Parameter('y', 10.0, float, 'y-coordinate [mm]'),
                   Parameter('z', 5.0, float, 'z-coordinate [mm]')
                   ]),
        Parameter('num_points',
                  [Parameter('x', 11, int, 'number of x points to scan'),
                   Parameter('y', 11, int, 'number of y points to scan'),
                   Parameter('z', 11, int, 'number of z points to scan')
                   ]),
        Parameter('exp_to_do', [Parameter('fluorescence', True, bool, 'measure the NV fluorescence'),
                                Parameter('esr', True, bool, 'measure the ESR of NV'),
                                Parameter('esr2', True, bool,
                                          'measure the ESR of NV at two different frequencies')]),
        Parameter('exp_settings', [
            Parameter('fluorescence_time_per_pt', 0.4, float, 'time for fluorescence measurement at each point (s)'),
            Parameter('esr_mw_pwr', -10, float, 'microwave power for ESR scan'),
            Parameter('esr_avg_min', 12, int, 'minimum number of esr averages'),
            Parameter('esr_avg_max', 50, int, 'maximum number of esr averages'),
            Parameter('esr_cntr_freq', 2.82e9, float, 'center frequency for ESR scan'),
            Parameter('esr_freq_range', 8.5e7, float, 'frequency range for ESR scan (suggest 6e7 - 9e7)'),
            Parameter('esr2_cntr_freq', 2.99e9, float, 'center frequency for the second ESR scan'),
            Parameter('esr2_freq_range', 8.5e7, float, 'frequency range for the second ESR scan(suggest 6e7 - 9e7)'),
            Parameter('esr_ini_stab_time', 1, int, 'laser power stabilization time (sec)'),
            Parameter('esr_num_of_pts', 65, int, 'number of frequency points for ESR scan'),
            Parameter('esr_time_per_pt', 0.02, [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1],
                      'integration time for each point in the fast ESR scan (suggest 0.02-0.04)'),
            Parameter('esrfit_num_of_peaks', 1, [-1, 1, 2],
                      'specify number of peaks for fitting. if not specifying the number of peaks, choose -1'),
            Parameter('esrfit_minimum_counts', 0.9, float,
                      'minumum counts for an ESR to not be considered noise (suggest 0.8 - 1.01 if esr is normalized)'),
            Parameter('esrfit_contrast_factor', 3.0, float,
                      'minimum contrast for an ESR to not be considered noise (suggest 3.0-4.0)'),
            Parameter('to_plot', 'contrast', ['fwhm', 'contrast'], 'choose to plot fwhm or contrast in 1D sweep')
        ]),
        Parameter('tracking_settings', [Parameter('track_focus', 'autofocus', ['optimize_z', 'autofocus', 'None'],
                                                  'choose the method for tracking (optimize_z is recommended)'),
                                        Parameter('track_focus_every_N', 18, int, 'track every N points'),
                                        Parameter('track_to_nv', True, bool,
                                                  'check to use find_nv to track to the NV'),
                                        Parameter('track_to_nv_every_N', 5, int, 'track every N points'),
                                        Parameter('track_frequency', True, bool,
                                                  'keep track of the frequency and set it to the central frequency of the next ESR scan (recommended)'),
                                        Parameter('track_frequency_every_N', 1, int, 'track every N points')]),
        Parameter('optimize_z_settings', [Parameter('sweep_range', 0.5, float, 'z voltage range for optimizing scan (suggest 0.6)'),
                                          Parameter('num_points', 36, int, 'number of z points to scan (suggest 41)'),
                                          ]),
        Parameter('autofocus_settings', [Parameter('scan_width', 0.6, float, 'z voltage range for optimizing scan (suggest 0.6-0.9)'),
                                         Parameter('num_sweep_points', 6, int,
                                                   'number of values to sweep between min and max voltage (suggest 6-10)'),
                                         ]),
        Parameter('find_nv_settings',
                  [Parameter('sweep_range', 0.35, float, 'voltage range to sweep over to find a max (suggest 0.4)'),
                   Parameter('num_points', 61, int, 'number of points to sweep in the sweep range'),
                   Parameter('nv_size', 21, int,
                             'size of nv in pixels - need to be refined!! needs to be odd number!!!'),
                   Parameter('min_mass', 80, int, 'TEMP: brightness of nv - need to be refined!! (suggest 60-100)'),
                   ])
    ]

    _INSTRUMENTS = {'XServo': MagnetX, 'YServo': MagnetY, 'ZServo': MagnetZ,
                    'mw_gen': R8SMicrowaveGenerator}

    _SCRIPTS = {'find_nv': FindNV, 'daq_read_counter': Daq_Read_Counter, 'esr': ESR_FastSwp_RnS_FitGuaranteed,
                'autofocus': AutoFocusDAQ, 'optimize_z': optimize}

    def __init__(self, instruments = None, scripts = None, name = None, settings = None, log_function = None, data_path = None):
        """
        Example of a script that makes use of an instrument
        Args:
            instruments: instruments the script will make use of
            name (optional): name of script, if empty same as class name
            settings (optional): settings for this script, if empty same as default settings
        """

        # call init of superclass
        Script.__init__(self, name, settings=settings, instruments=instruments, scripts=scripts,
                        log_function=log_function, data_path=data_path)

    def _get_instr(self):
        """
        Assigns an instrument relevant to the 1D scan axis.
        """
        if self.settings['scan_axis'] == 'x':
            return self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'y':
            return self.instruments['YServo']['instance']
        elif self.settings['scan_axis'] == 'z':
            return self.instruments['ZServo']['instance']

    def _get_instr_2D(self):
        """
        Assigns an instrument relevant to the 2D scan axis.
        """
        if self.settings['scan_axis'] == 'xy':
            return self.instruments['XServo']['instance'], self.instruments['YServo']['instance']
        elif self.settings['scan_axis'] == 'yx':
            return self.instruments['YServo']['instance'], self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'xz':
            return self.instruments['XServo']['instance'], self.instruments['ZServo']['instance']
        elif self.settings['scan_axis'] == 'zx':
            return self.instruments['ZServo']['instance'], self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'yz':
            return self.instruments['YServo']['instance'], self.instruments['ZServo']['instance']
        elif self.settings['scan_axis'] == 'zy':
            return self.instruments['ZServo']['instance'], self.instruments['YServo']['instance']

    def _get_scan_positions(self, verbose=True):
        '''
        Returns an array of points to go to in the 1D scan.
        '''
        if self.settings['scan_axis'] in ['x', 'y', 'z']:
            min_pos = self.settings['sweep_center'][self.settings['scan_axis']] - 0.5 * self.settings['sweep_span'][
                self.settings['scan_axis']]

            max_pos = self.settings['sweep_center'][self.settings['scan_axis']] + 0.5 * self.settings['sweep_span'][
                self.settings['scan_axis']]
            num_points = self.settings['num_points'][self.settings['scan_axis']]
            scan_pos = [np.linspace(min_pos, max_pos, num_points)]
            if verbose:
                print('-------------Scan Settings---------------')
                print('Scan axis:' + self.settings['scan_axis'])
                print('Values for the primary scan are (in mm):' + self.settings['scan_axis'] + ' = ', scan_pos)

            return scan_pos
        else:
            print('NotImplementedError: multiple dimensional scans not yet implemented')
            NotImplementedError('multiple dimensional scans not yet implemented')

    def _get_scan_positions_2D(self, verbose=True):
        if self.settings['scan_axis'] in ['xy', 'yx', 'xz', 'zx', 'yz', 'zy']:
            # print('for calculating primary positions:')
            # print(self.settings['sweep_center'][self.settings['scan_axis'][0]])
            # print(self.settings['sweep_span'][
            #           self.settings['scan_axis'][0]])
            # print('for calculating secondary positions:')
            # print(self.settings['sweep_center'][self.settings['scan_axis'][1]])
            # print(self.settings['sweep_span'][
            #           self.settings['scan_axis'][1]])

            primary_min_pos = self.settings['sweep_center'][self.settings['scan_axis'][0]] - self.settings['sweep_span'][
                self.settings['scan_axis'][0]]/2.0

            primary_max_pos = self.settings['sweep_center'][self.settings['scan_axis'][0]] +  self.settings['sweep_span'][
                self.settings['scan_axis'][0]]/2.0
            primary_num_points = self.settings['num_points'][self.settings['scan_axis'][0]]
            secondary_min_pos = self.settings['sweep_center'][self.settings['scan_axis'][1]] - self.settings['sweep_span'][self.settings['scan_axis'][1]]/2.0
            secondary_max_pos = self.settings['sweep_center'][self.settings['scan_axis'][1]] + self.settings['sweep_span'][self.settings['scan_axis'][1]]/2.0
            secondary_num_points = self.settings['num_points'][self.settings['scan_axis'][1]]

            primary_scan_pos = np.linspace(primary_min_pos, primary_max_pos, num = primary_num_points)
            secondary_scan_pos = np.linspace(secondary_min_pos, secondary_max_pos, num = secondary_num_points)

            if verbose:
                print('-------------Scan Settings---------------')
                print('Scan axis:' + self.settings['scan_axis'])
                # print('primary_min_pos',primary_min_pos)
                # print('primary_max_pos',primary_max_pos )
                # print('secondary_min_pos',secondary_min_pos )
                # print('secondary_max_pos', secondary_max_pos)
                print('Values for the primary scan are (in mm): ' + self.settings['scan_axis'][0] + ' = ', primary_scan_pos)
                print('Values for the secondary scan are (in mm): ' + self.settings['scan_axis'][1] + ' = ', secondary_scan_pos)
            return primary_scan_pos, secondary_scan_pos

        else:
            print('NotImplementedError: dimension is not right.')
            NotImplementedError('Dimension is not right')

    @staticmethod
    def pts_to_extent(pta, ptb):
        """

        Args:
            pta: point a
            ptb: point b
            roi_mode:   mode how to calculate region of interest
                        corner: pta and ptb are diagonal corners of rectangle.
                        center: pta is center and ptb is extend or rectangle

        Returns: extend of region of interest [xVmin, xVmax, yVmax, yVmin]

        """
        xVmin = pta['x'] - float(ptb['x']) / 2.
        xVmax = pta['x'] + float(ptb['x']) / 2.
        yVmin = pta['y'] - float(ptb['y']) / 2.
        yVmax = pta['y'] + float(ptb['y']) / 2.
        zVmin = pta['z'] - float(ptb['z']) / 2.
        zVmax = pta['z'] + float(ptb['z']) / 2.

        return [xVmin, xVmax, yVmin, yVmax, zVmin, zVmax]

    def meas_fluorescence(self, index = -1):

        # update the tag of the daq_read_counter script
        if index >= 0:
            self.scripts['daq_read_counter'].settings['tag'] = 'daq_read_counter_ind' + str(index)

        # run daq_read_counter or the relevant script to get fluorescence
        print('==> Start measuring FLUORESCENCE...')
        self.scripts['daq_read_counter'].run()
        time.sleep(self.settings['exp_settings']['fluorescence_time_per_pt'])
        self.scripts['daq_read_counter'].stop()
        data = self.scripts['daq_read_counter'].data['counts']
        print('--> Mean counts = {:0.2f} kcps'.format(np.mean(data)))
        return data

    def do_esr(self, esr_cntr_freq, esr_freq_range, label = None, index = -1, verbose=False):

        # update the tag of the esr script
        if label is not None and index >= 0:
            self.scripts['esr'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['esr'].settings['tag'] = label
        elif index >= 0:
            self.scripts['esr'].settings['tag'] = 'esr_ind' + str(index)

        # set the right parameters for the ESR scan
        self.scripts['esr'].settings['power_out'] = self.settings['exp_settings']['esr_mw_pwr']
        self.scripts['esr'].settings['esr_avg_min'] = self.settings['exp_settings']['esr_avg_min']
        self.scripts['esr'].settings['esr_avg_max'] = self.settings['exp_settings']['esr_avg_max']
        self.scripts['esr'].settings['freq_start'] = float(esr_cntr_freq)
        self.scripts['esr'].settings['freq_stop'] = float(esr_freq_range)
        self.scripts['esr'].settings['range_type'] = 'center_range'
        self.scripts['esr'].settings['freq_points'] = self.settings['exp_settings']['esr_num_of_pts']
        self.scripts['esr'].settings['ini_stab_time'] = self.settings['exp_settings']['esr_ini_stab_time']
        self.scripts['esr'].settings['time_per_pt'] = self.settings['exp_settings']['esr_time_per_pt']
        self.scripts['esr'].settings['fit_constants']['num_of_peaks'] = self.settings['exp_settings'][
            'esrfit_num_of_peaks']
        self.scripts['esr'].settings['fit_constants']['minimum_counts'] = self.settings['exp_settings'][
            'esrfit_minimum_counts']
        self.scripts['esr'].settings['fit_constants']['contrast_factor'] = self.settings['exp_settings'][
            'esrfit_contrast_factor']
        print('==> Start measuring ESR...')
        self.scripts['esr'].run()
        esr_fit_data = self.scripts['esr'].data['fit_params']
        if verbose:
            print('len(esr_fit_data) =  ', esr_fit_data)

        return esr_fit_data

    def _function(self):
        # print('self._abort1:', self._abort)
        self.flag_image0_update_plot = True

        def set_tracking_parameters():
            # set the parameters for all the scripts
            # optimize_z settings
            self.scripts['optimize_z'].update({'optimizing_x': False})
            self.scripts['optimize_z'].update({'optimizing_y': False})
            self.scripts['optimize_z'].update({'optimizing_z': True})
            self.scripts['optimize_z'].settings['sweep_range'].update(
                {'z': self.settings['optimize_z_settings']['sweep_range']})
            self.scripts['optimize_z'].settings['num_points'].update(
                {'z': self.settings['optimize_z_settings']['num_points']})
            # find_nv settings
            self.scripts['find_nv'].update({'center_on_current_location': True})
            self.scripts['find_nv'].update({'sweep_range': self.settings['find_nv_settings']['sweep_range']})
            self.scripts['find_nv'].update({'num_points': self.settings['find_nv_settings']['num_points']})
            self.scripts['find_nv'].update({'nv_size': self.settings['find_nv_settings']['nv_size']})
            self.scripts['find_nv'].update({'min_mass': self.settings['find_nv_settings']['min_mass']})
            # autofocus settings
            self.scripts['autofocus'].update({'scan_width': self.settings['autofocus_settings']['scan_width']})
            self.scripts['autofocus'].update(
                {'num_sweep_points': self.settings['autofocus_settings']['num_sweep_points']})
            self.scripts['autofocus'].scripts['take_image'].settings['num_points'].update({'x': 51})
            self.scripts['autofocus'].scripts['take_image'].settings['num_points'].update({'y': 51})

        def do_tracking(index):

            # update the tag of scripts
            if index >= 0:
                self.scripts['find_nv'].settings['tag'] = 'find_nv_ind' + str(index)
                self.scripts['optimize_z'].settings['tag'] = 'optimize_z_ind' + str(index)
                self.scripts['autofocus'].settings['tag'] = 'autofocus_ind' + str(index)

            # track to the NV if it's time to
            if self.settings['tracking_settings']['track_focus'] != 'None':
                if index > 0 and index % self.settings['tracking_settings']['track_focus_every_N'] == 0:
                    print('==> Do track_focus now:')
                    if self.settings['tracking_settings']['track_focus'] == 'optimize_z':
                        print('    ==> optimize_z starts')
                        self.flag_optimize_z_plot = True
                        self.scripts['optimize_z'].run()
                        self.flag_find_nv_plot = True
                        print('==> find_NV starts (after tracking focus)')
                        self.scripts['find_nv'].run()

                    elif self.settings['tracking_settings']['track_focus'] == 'autofocus':
                        print('    ==> autofocus starts')
                        self.flag_autofocus_plot = True
                        self.scripts['autofocus'].run()

                        print('==> find_NV starts (after tracking focus)')
                        self.flag_find_nv_plot = True
                        self.scripts['find_nv'].run()
            if self.settings['tracking_settings']['track_to_nv']:
                # if index > 0 and index % self.settings['tracking_settings']['track_to_nv_every_N'] == 0 & index % self.settings['tracking_settings']['track_focus_every_N'] != 0:
                if index == 0 or index % self.settings['tracking_settings']['track_to_nv_every_N'] == 0:
                    self.flag_find_nv_plot = True
                    print('==> find_NV starts')
                    self.scripts['find_nv'].run()
            if self.settings['tracking_settings']['track_frequency']:
                if index > 0 and index % self.settings['tracking_settings']['track_frequency_every_N'] == 0:
                    print('==> track_frequency')
                    self.esr_cntr_freq_todo = self.current_esr_cntr_freq
                    self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

        if self.settings['to-do'] == 'read':
            Zservo_position = self.instruments['ZServo']['instance']._get_position()
            Zservo_velocity = self.instruments['ZServo']['instance']._get_velocity()
            self.log('MagnetZ position: ' + str(Zservo_position) + 'mm, velocity = ' + str(Zservo_velocity) + 'mm/s')
            Yservo_position = self.instruments['YServo']['instance']._get_position()
            Yservo_velocity = self.instruments['YServo']['instance']._get_velocity()
            self.log('MagnetY position: ' + str(Yservo_position) + 'mm, velocity = ' + str(Yservo_velocity) + 'mm/s')
            Xservo_position = self.instruments['XServo']['instance']._get_position()
            Xservo_velocity = self.instruments['XServo']['instance']._get_velocity()
            self.log('MagnetX position: ' + str(Xservo_position) + 'mm, velocity = ' + str(Xservo_velocity) + 'mm/s')

        else:
            # print('self._abort2:', self._abort)
            # initialize the servo positions
            if self.settings['servo_initial']['initialize'] or self.settings['to-do'] == 'initialize':
                print('----------- Servo Initialization -----------')
                print('Xservo:')
                self.instruments['XServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Xservo_min']})
                self.instruments['XServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Xservo_max']})
                self.instruments['XServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['XServo']['instance'].update({'position': self.settings['servo_initial']['Xservo']})
                servo_move = self.instruments['XServo']['instance']._move_servo(self.settings['servo_initial']['Xservo'])
                if not servo_move:
                    print('Xservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True

                print('Yservo:')
                self.instruments['YServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Yservo_min']})
                self.instruments['YServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Yservo_max']})
                self.instruments['YServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['YServo']['instance'].update({'position': self.settings['servo_initial']['Yservo']})
                servo_move = self.instruments['YServo']['instance']._move_servo(self.settings['servo_initial']['Yservo'])
                if not servo_move:
                    print('Yservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True


                print('Zservo:')
                self.instruments['ZServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Zservo_min']})
                self.instruments['ZServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Zservo_max']})
                self.instruments['ZServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['ZServo']['instance'].update({'position': self.settings['servo_initial']['Zservo']})
                servo_move = self.instruments['ZServo']['instance']._move_servo(self.settings['servo_initial']['Zservo'])
                if not servo_move:
                    print('Zservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True

                print('>>>> Servo initialization done')

            if self.settings['to-do'] == 'move':
                print('----------- Servo moving along the scanning axis -----------')
                if self.settings['scan_axis'] in ['x', 'y', 'z']:
                    scan_instr = self._get_instr()
                    print('     ' + self.settings['scan_axis'][0] + ' Servo is moving to ' + self.settings['scan_axis'][
                        0] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][0]]) + 'mm')
                    # scan_instr.update({'position': self.settings['move_to'][self.settings['scan_axis'][0]]})
                    servo_move = scan_instr._move_servo(self.settings['move_to'][self.settings['scan_axis'][0]])
                    if not servo_move:
                        print(self.settings['scan_axis'] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True

                elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz']:
                    scan_instr_pri, scan_instr_sec = self._get_instr_2D()
                    print(self.settings['scan_axis'][1] + ' Servo is moving to ' + self.settings['scan_axis'][
                        1] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][1]]) + 'mm')
                    # scan_instr_sec.update({'position': self.settings['move_to'][self.settings['scan_axis'][1]]})
                    servo_move = scan_instr_sec._move_servo(self.settings['move_to'][self.settings['scan_axis'][1]])
                    if not servo_move:
                        print(self.settings['scan_axis'][1] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True
                    print(self.settings['scan_axis'][0] + ' Servo is moving to ' + self.settings['scan_axis'][
                        0] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][0]]) + 'mm')
                    # scan_instr_pri.update({'position': self.settings['move_to'][self.settings['scan_axis'][0]]})
                    servo_move = scan_instr_pri._move_servo(self.settings['move_to'][self.settings['scan_axis'][0]])
                    if not servo_move:
                        print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True
                print('>>>> Servo Moving done')

            elif self.settings['to-do'] == 'sweep':

                # print('self._abort3:', self._abort)

                # ESR frequency initial settings (for both 1D and 2D)
                self.current_esr_cntr_freq = self.settings['exp_settings']['esr_cntr_freq']
                self.current_esr2_cntr_freq = self.settings['exp_settings']['esr2_cntr_freq']
                self.esr_cntr_freq_todo = self.current_esr_cntr_freq
                self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

                set_tracking_parameters()
                # print('self._abort4:', self._abort)

                # 1D scan (forward and backward)
                if self.settings['scan_axis'] in ['x', 'y', 'z']:
                    # get the relevant instrument for controlling the magnet.
                    scan_instr = self._get_instr()
                    # print('self._abort5:', self._abort)
                    # scan_instr._connect()
                    scan_instr.update({'velocity': self.settings['servo_initial']['moving_velocity']})
                    # get positions for the scan.
                    scan_pos = self._get_scan_positions()
                    # print('self._abort6:', self._abort)

                    # forward and backward sweeps
                    self.data = {'counts': deque(), 'counts_r': deque(), 'esr_fo': deque(), 'esr_fo_r': deque(),
                                 'esr_wo': deque(), 'esr_wo_r': deque(), 'esr_ctrst': deque(), 'esr_ctrst_r': deque(),
                                 'esr2_fo': deque(), 'esr2_fo_r': deque(), 'esr2_wo': deque(), 'esr2_wo_r': deque(),
                                 'esr2_ctrst': deque(), 'esr2_ctrst_r': deque()}


                    self.data['positions'] = scan_pos[0]
                    self.data['positions_r'] = scan_pos[0][::-1]

                    self.positions = {'positions': deque()}
                    # print('self._abort7:', self._abort)

                    # loop over scan positions and call the scripts
                    index = 0
                    # for i in range(0, self.settings['sweep_settings']['num_points']):
                    # print('start sweeping!')

                    # 1D Forward Sweep
                    for pos_index in range(0, len(self.data['positions'])):
                        print('len(self.data[]',len(self.data['positions']))
                        if self._abort:
                            break

                        # Set the sweeping TDC001 to be at the initial position
                        new_pos = float(self.data['positions'][pos_index])
                        print('============= Start (index = ' + str(index) + ', Forward) =================')
                        print('----------- Magnet Position: {:0.2f} mm -----------'.format(new_pos))
                        # scan_instr.update({'position': new_pos})  # actually move the instrument to that location.
                        servo_move = scan_instr._move_servo(new_pos)
                        if not servo_move:
                            print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')

                        # If this is not within the safety limits of the instruments, it will not actually move and say so in the log

                        # Do the tracking if it's time to
                        print('---------------- Tracking ----------------')
                        do_tracking(index)

                        # Do the actual measurements
                        print('---------------- Experiment ----------------')
                        if self.settings['exp_to_do']['fluorescence']:
                            fluor_data = self.meas_fluorescence(index=index)
                            # add to output structures which will be plotted
                            self.data['counts'].append(np.mean(fluor_data))
                        if self.settings['exp_to_do']['esr']:
                            esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                       self.settings['exp_settings']['esr_freq_range'], label='esr1',
                                                       index=index)

                            if esr_fit_data is None:
                                print('--> No ESR fitting')
                                # add to output structures which will be plotted
                                self.data['esr_fo'].append(0.0)
                                self.data['esr_wo'].append(0.0)
                                self.data['esr_ctrst'].append(0.0)

                            elif len(esr_fit_data) == 4:
                                if esr_fit_data[3] < 0.5e6:
                                    self.data['esr_fo'].append(0.0)
                                    self.data['esr_wo'].append(0.0)
                                    self.data['esr_ctrst'].append(0.0)
                                    print(
                                        '--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print(
                                        '--> Good, find one ESR peak :). fo = ' + str(
                                            esr_fit_data[2]) + ' Hz, wo = ' + str(
                                            esr_fit_data[3]) + 'Hz')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo'].append(esr_fit_data[2])
                                    self.data['esr_wo'].append(esr_fit_data[3])
                                    self.data['esr_ctrst'].append(esr_fit_data[1])
                                    # update the ESR center frequency
                                    self.current_esr_cntr_freq = esr_fit_data[2]

                            elif len(esr_fit_data) == 6:
                                # self.data['esr_fo'].append(0.0)
                                # self.data['esr_wo'].append(0.0)
                                # self.data['esr_ctrst'].append(0.0)
                                # print('--> Find two ESRs peak, but only one is expected. No Fit is recorded.')
                                if esr_fit_data[1] < 0.5e6:
                                    self.data['esr_fo'].append(0.0)
                                    self.data['esr_wo'].append(0.0)
                                    self.data['esr_ctrst'].append(0.0)
                                    print(
                                        '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print('--> Find two ESR peaks, only record the first peak info')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo'].append(esr_fit_data[4])
                                    self.data['esr_wo'].append(esr_fit_data[1])
                                    self.data['esr_ctrst'].append(esr_fit_data[2])
                                    # update the ESR center frequency
                                    self.current_esr_cntr_freq = esr_fit_data[4]
                        if self.settings['exp_to_do']['esr2']:
                            esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                                                        self.settings['exp_settings']['esr2_freq_range'], label='esr2',
                                                        index=index)
                            if esr2_fit_data is None:
                                print('--> No ESR2 fitting')
                                # add to output structures which will be plotted
                                self.data['esr2_fo'].append(0.0)
                                self.data['esr2_wo'].append(0.0)
                                self.data['esr2_ctrst'].append(0.0)

                            elif len(esr2_fit_data) == 4:
                                if esr2_fit_data[3] < 0.5e6:
                                    self.data['esr2_fo'].append(0.0)
                                    self.data['esr2_wo'].append(0.0)
                                    self.data['esr2_ctrst'].append(0.0)
                                    print(
                                        '--> Find one ESR2 peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print('--> Good, find one ESR2 peak :). fo = ' + str(
                                        esr2_fit_data[2]) + ' Hz, wo = ' + str(
                                        esr2_fit_data[3]) + 'Hz')
                                    # add to output structures which will be plotted
                                    self.data['esr2_fo'].append(esr2_fit_data[2])
                                    self.data['esr2_wo'].append(esr2_fit_data[3])
                                    self.data['esr2_ctrst'].append(esr2_fit_data[1])
                                    # update the ESR2 center frequency
                                    self.current_esr2_cntr_freq = esr2_fit_data[2]
                            elif len(esr2_fit_data) == 6:
                                # self.data['esr2_fo'].append(0.0)
                                # self.data['esr2_wo'].append(0.0)
                                # self.data['esr2_ctrst'].append(0.0)
                                # print(
                                #     '--> Find two ESR2 peak, but only one is expected. No Fit is recorded.')
                                if esr2_fit_data[1] < 0.5e6:
                                    self.data['esr2_fo'].append(0.0)
                                    self.data['esr2_wo'].append(0.0)
                                    self.data['esr2_ctrst'].append(0.0)
                                    print(
                                        '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print('--> Find two ESR2 peaks, only record the second peak info')
                                    # add to output structures which will be plotted
                                    self.data['esr2_fo'].append(esr2_fit_data[5])
                                    self.data['esr2_wo'].append(esr2_fit_data[1])
                                    self.data['esr2_ctrst'].append(esr2_fit_data[3])

                                    # update the ESR2 center frequency
                                    self.current_esr2_cntr_freq = esr2_fit_data[5]

                        print('==================== Finished (Forward) =======================')
                        # record the position
                        self.positions['positions'].append(new_pos)
                        self.progress = index * 100. / (len(self.data['positions']) + len(self.data['positions_r']))
                        self.updateProgress.emit(int(self.progress))

                        index = index + 1
                    # the end of the for loop for the forward 1D sweep

                    # 1D Backward Sweep
                    for pos_r_index in range(0, len(self.data['positions_r'])):
                        if self._abort:
                            break

                        # Set the sweeping TDC001 to be at the initial position for the backward sweep
                        new_pos = float(self.data['positions_r'][pos_r_index])
                        print('============ Start (index = ' + str(index) + ', Backward) =================')
                        print('----------- Magnet Position: {:0.2f} mm -----------'.format(new_pos))
                        # scan_instr.update({'position': new_pos})  # actually move the instrument to that location.
                        servo_move = scan_instr._move_servo(new_pos)
                        if not servo_move:
                            print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')
                        # If this is not within the safety limits of the instruments, it will not actually move and say so in the log

                        # Do the tracking if it's time to
                        print('---------------- Tracking ----------------')
                        do_tracking(index)

                        # Do the actual measurements
                        print('---------------- Experiment ----------------')
                        if self.settings['exp_to_do']['fluorescence']:
                            fluor_data = self.meas_fluorescence(index=index)
                            # add to output structures which will be plotted
                            self.data['counts_r'].append(np.mean(fluor_data))
                        if self.settings['exp_to_do']['esr']:
                            esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                       self.settings['exp_settings']['esr_freq_range'], label='esr1',
                                                       index=index)

                            if esr_fit_data is None:
                                print('--> No ESR fitting')
                                # add to output structures which will be plotted
                                self.data['esr_fo_r'].append(0.0)
                                self.data['esr_wo_r'].append(0.0)
                                self.data['esr_ctrst_r'].append(0.0)

                            elif len(esr_fit_data) == 4:
                                if esr_fit_data[3] < 0.5e6:
                                    self.data['esr_fo_r'].append(0.0)
                                    self.data['esr_wo_r'].append(0.0)
                                    self.data['esr_ctrst_r'].append(0.0)
                                    print(
                                        '--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print(
                                        '--> Good, find one ESR peak :). fo = ' + str(
                                            esr_fit_data[2]) + ' Hz, wo = ' + str(
                                            esr_fit_data[3]) + 'Hz')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo_r'].append(esr_fit_data[2])
                                    self.data['esr_wo_r'].append(esr_fit_data[3])
                                    self.data['esr_ctrst_r'].append(esr_fit_data[1])
                                    # update the ESR center frequency
                                    self.current_esr_cntr_freq = esr_fit_data[2]

                            elif len(esr_fit_data) == 6:
                                # self.data['esr_fo_r'].append(0.0)
                                # self.data['esr_wo_r'].append(0.0)
                                # self.data['esr_ctrst_r'].append(0.0)
                                # print(
                                #     '--> Find two ESR peak, but only one is expected. No Fit is recorded.')
                                if esr_fit_data[1] < 0.5e6:
                                    self.data['esr_fo_r'].append(0.0)
                                    self.data['esr_wo_r'].append(0.0)
                                    self.data['esr_ctrst_r'].append(0.0)
                                    print(
                                        '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print('--> Find two ESR peaks, only record the first peak info')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo_r'].append(esr_fit_data[4])
                                    self.data['esr_wo_r'].append(esr_fit_data[1])
                                    self.data['esr_ctrst_r'].append(esr_fit_data[2])
                                    # update the ESR center frequency
                                    self.current_esr_cntr_freq = esr_fit_data[4]
                        if self.settings['exp_to_do']['esr2']:
                            esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                                                        self.settings['exp_settings']['esr2_freq_range'], label='esr2',
                                                        index=index)
                            if esr2_fit_data is None:
                                print('--> No ESR2 fitting')
                                # add to output structures which will be plotted
                                self.data['esr2_fo_r'].append(0.0)
                                self.data['esr2_wo_r'].append(0.0)
                                self.data['esr2_ctrst_r'].append(0.0)

                            elif len(esr2_fit_data) == 4:
                                if esr2_fit_data[3] < 0.5e6:
                                    self.data['esr2_fo_r'].append(0.0)
                                    self.data['esr2_wo_r'].append(0.0)
                                    self.data['esr2_ctrst_r'].append(0.0)
                                    print(
                                        '--> Find one ESR2 peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print('--> Good, find one ESR2 peak :). fo = ' + str(
                                        esr2_fit_data[2]) + ' Hz, wo = ' + str(
                                        esr2_fit_data[3]) + 'Hz')
                                    # add to output structures which will be plotted
                                    self.data['esr2_fo_r'].append(esr2_fit_data[2])
                                    self.data['esr2_wo_r'].append(esr2_fit_data[3])
                                    self.data['esr2_ctrst_r'].append(esr2_fit_data[1])
                                    # update the ESR2 center frequency
                                    self.current_esr2_cntr_freq = esr2_fit_data[2]
                            elif len(esr2_fit_data) == 6:
                                # self.data['esr2_fo_r'].append(0.0)
                                # self.data['esr2_wo_r'].append(0.0)
                                # self.data['esr2_ctrst_r'].append(0.0)
                                # print(
                                #     '--> Find two ESR2 peak, but only one is expected. No Fit is recorded.')

                                if esr2_fit_data[1] < 0.5e6:
                                    self.data['esr2_fo_r'].append(0.0)
                                    self.data['esr2_wo_r'].append(0.0)
                                    self.data['esr2_ctrst_r'].append(0.0)
                                    print(
                                        '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print('--> Find two ESR2 peaks, only record the first peak info')
                                    # add to output structures which will be plotted
                                    self.data['esr2_fo_r'].append(esr2_fit_data[5])
                                    self.data['esr2_wo_r'].append(esr2_fit_data[1])
                                    self.data['esr2_ctrst_r'].append(esr2_fit_data[3])
                                    # update the ESR2 center frequency
                                    self.current_esr2_cntr_freq = esr2_fit_data[5]

                        print('=================== Finished (Backward) =======================')
                        # record the position
                        self.positions['positions'].append(new_pos)
                        self.progress = index * 100. / (len(self.data['positions']) + len(self.data['positions_r']))
                        self.updateProgress.emit(int(self.progress))

                        index = index + 1

                        pass
                    # the end of the for loop for the backward 1D sweep
                    pass

                    # clean up data, as in daq_read_counter
                    # convert deque object to numpy array or list
                    if 'counts' in self.data.keys() is not None:
                        # self.data['counts'] = list(self.data['counts'])
                        self.data['counts'] = np.asarray(self.data['counts'])
                    if 'esr_fo' in self.data.keys() is not None:
                        # self.data['esr_fo'] = list(self.data['esr_fo'])
                        self.data['esr_fo'] = np.asarray(self.data['esr_fo'])
                    if 'esr_wo' in self.data.keys() is not None:
                        # self.data['esr_wo'] = list(self.data['esr_wo'])
                        self.data['esr_wo'] = np.asarray(self.data['esr_wo'])
                    if 'esr_ctrst' in self.data.keys() is not None:
                        self.data['esr_ctrst'] = np.asarray(self.data['esr_ctrst'])
                    if 'esr2_fo' in self.data.keys() is not None:
                        # self.data['esr2_fo'] = list(self.data['esr2_fo'])
                        self.data['esr2_fo'] = np.asarray(self.data['esr2_fo'])
                    if 'esr2_wo' in self.data.keys() is not None:
                        # self.data['esr2_wo'] = list(self.data['esr2_wo'])
                        self.data['esr2_wo'] = np.asarray(self.data['esr2_wo'])
                    if 'esr2_ctrst' in self.data.keys() is not None:
                        self.data['esr2_ctrst'] = np.asarray(self.data['esr2_ctrst'])
                    if 'counts_r' in self.data.keys() is not None:
                        # self.data['counts'] = list(self.data['counts'])
                        self.data['counts_r'] = np.asarray(self.data['counts_r'])
                    if 'esr_fo_r' in self.data.keys() is not None:
                        # self.data['esr_fo'] = list(self.data['esr_fo'])
                        self.data['esr_fo_r'] = np.asarray(self.data['esr_fo_r'])
                    if 'esr_wo_r' in self.data.keys() is not None:
                        # self.data['esr_wo'] = list(self.data['esr_wo'])
                        self.data['esr_wo_r'] = np.asarray(self.data['esr_wo_r'])
                    if 'esr_ctrst_r' in self.data.keys() is not None:
                        self.data['esr_ctrst_r'] = np.asarray(self.data['esr_ctrst_r'])
                    if 'esr2_fo_r' in self.data.keys() is not None:
                        # self.data['esr2_fo'] = list(self.data['esr2_fo'])
                        self.data['esr2_fo_r'] = np.asarray(self.data['esr2_fo_r'])
                    if 'esr2_wo_r' in self.data.keys() is not None:
                        # self.data['esr2_wo'] = list(self.data['esr2_wo'])
                        self.data['esr2_wo_r'] = np.asarray(self.data['esr2_wo_r'])
                    if 'esr2_ctrst_r' in self.data.keys() is not None:
                        self.data['esr2_ctrst_r'] = np.asarray(self.data['esr2_ctrst_r'])
                # 2D scan (forward and backward)
                elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz']:

                    # get the relevant instrument for controlling the magnet.
                    scan_instr_pri, scan_instr_sec = self._get_instr_2D()
                    scan_instr_pri.update({'velocity': self.settings['servo_initial']['moving_velocity']})
                    scan_instr_sec.update({'velocity': self.settings['servo_initial']['moving_velocity']})

                    # get the positions for the scan.
                    scan_pos_pri, scan_pos_sec = self._get_scan_positions_2D()
                    scan_pos_pri_r = scan_pos_pri[::-1]

                    # [self.xVmin, self.xVmax, self.yVmin, self.yVmax, self.zVmin, self.zVmax] = self.pts_to_extent(
                    #     self.settings['sweep_center'], self.settings['sweep_span'])

                    # Data Structure
                    # self.data = {'bounds': [scan_pos_pri[0], scan_pos_pri[-1], scan_pos_sec[0], scan_pos_sec[-1],],
                    self.data = {'bounds': [scan_pos_pri[0], scan_pos_pri[-1], scan_pos_sec[-1], scan_pos_sec[0], ],
                                 'scan_pos_pri': scan_pos_pri, 'scan_pos_sec': scan_pos_sec,
                                 'counts': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'counts_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr_fo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr_fo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr_wo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr_wo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr_ctrst': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr_ctrst_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr2_fo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr2_fo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr2_wo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr2_wo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr2_ctrst': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                                 'esr2_ctrst_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri))))}

                    print('bounds:', self.data['bounds'])

                    # 2D forward and backward sweeps
                    index = 0
                    for pos_sec_index in range(0, len(scan_pos_sec)):
                        if self._abort:
                            break

                        # Set the sweeping TDC001 to be at the initial position
                        new_pos_sec = float(scan_pos_sec[pos_sec_index])
                        print('★★★★★★★★★★★★★  Start (index = ' + str(index) + ', Secondary) ★★★★★★★★★★★★★★')
                        print('------ Moving to Secondary Position: ' + self.settings['scan_axis'][
                            1] + ' = {:0.2f} mm --------'.format(new_pos_sec))
                        # scan_instr_sec.update({'position': new_pos_sec})  # actually move the instrument to that location.
                        servo_move = scan_instr_sec._move_servo(new_pos_sec)
                        if not servo_move:
                            print(self.settings['scan_axis'][1] + 'servo fails to move. Experiment stopped.')
                        # If this is not within the safety limits of the instruments, it will not actually move and say so in the log

                        # Forward Primary loop
                        for pos_pri_index in range(0, len(scan_pos_pri)):
                            if self._abort:
                                break
                            new_pos_pri = float(scan_pos_pri[pos_pri_index])
                            print('============= Start (index = ' + str(index) + ', Primary, Forward) ============')
                            print('------ Moving to Primary Position: ' + self.settings['scan_axis'][
                                0] + ' = {:0.2f} mm --------'.format(new_pos_pri))
                            # scan_instr_pri.update({'position': new_pos_pri})  # actually move the instrument to that location.
                            servo_move = scan_instr_pri._move_servo(new_pos_pri)
                            if not servo_move:
                                print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')

                            print('---------------- Tracking ----------------')
                            do_tracking(index)

                            # Do the actual measurements
                            print('---------------- Experiment ----------------')
                            if self.settings['exp_to_do']['fluorescence']:
                                fluor_data = self.meas_fluorescence(index=index)
                                # add to output structures which will be plotted
                                # self.data['counts'].append(np.mean(fluor_data))
                                self.data['counts'][pos_sec_index][pos_pri_index] = np.mean(fluor_data)
                            if self.settings['exp_to_do']['esr']:
                                esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                           self.settings['exp_settings']['esr_freq_range'],
                                                           label='esr1', index=index)

                                if esr_fit_data is None:
                                    print('--> No ESR fitting :(')
                                    # self.data['esr_fo'].append(0.0)
                                    # self.data['esr_wo'].append(0.0)

                                elif len(esr_fit_data) == 4:
                                    if esr_fit_data[3] < 0.5e6:
                                        # self.data['esr_fo'].append(0.0)
                                        # self.data['esr_wo'].append(0.0)
                                        print(
                                            '--> Find one ESR peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print(
                                            '--> Good, find one ESR peak :). fo = ' + str(
                                                esr_fit_data[2]) + ' Hz, wo = ' + str(
                                                esr_fit_data[3]) + 'Hz')
                                        # add to output structures which will be plotted
                                        # self.data['esr_fo'].append(esr_fit_data[2])
                                        # self.data['esr_wo'].append(esr_fit_data[3])
                                        self.data['esr_fo'][pos_sec_index][pos_pri_index] = esr_fit_data[2]
                                        self.data['esr_wo'][pos_sec_index][pos_pri_index] = esr_fit_data[3]
                                        self.data['esr_ctrst'][pos_sec_index][pos_pri_index] = esr_fit_data[1]

                                        # update the ESR center frequency
                                        self.current_esr_cntr_freq = esr_fit_data[2]

                                elif len(esr_fit_data) == 6:
                                    # print(
                                    #     '--> Find two ESR peaks, but only one is expected. No Fit is recorded.')
                                    if esr_fit_data[1] < 0.5e6:

                                        print(
                                            '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print('--> Find two ESR peaks, only record the first peak info')
                                        # add to output structures which will be plotted

                                        self.data['esr_fo'][pos_sec_index][pos_pri_index] = esr_fit_data[4]
                                        self.data['esr_wo'][pos_sec_index][pos_pri_index] = esr_fit_data[1]
                                        self.data['esr_ctrst'][pos_sec_index][pos_pri_index] = esr_fit_data[2]
                                        # update the ESR center frequency
                                        self.current_esr_cntr_freq = esr_fit_data[4]
                            if self.settings['exp_to_do']['esr2']:
                                esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                                                            self.settings['exp_settings']['esr2_freq_range'],
                                                            label='esr2', index=index)
                                if esr2_fit_data is None:
                                    print('--> No ESR2 fitting :(')
                                    # self.data['esr2_fo'].append(0.0)
                                    # self.data['esr2_wo'].append(0.0)
                                elif len(esr2_fit_data) == 4:
                                    if esr2_fit_data[3] < 0.5e6:
                                        print(
                                            '--> Find one ESR2 peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print('--> Good, find one ESR2 peak :). fo = ' + str(
                                            esr2_fit_data[2]) + ' Hz, wo = ' + str(
                                            esr2_fit_data[3]) + 'Hz')
                                        # add to output structures which will be plotted

                                        self.data['esr2_fo'][pos_sec_index][pos_pri_index] = esr2_fit_data[2]
                                        self.data['esr2_wo'][pos_sec_index][pos_pri_index] = esr2_fit_data[3]
                                        self.data['esr2_ctrst'][pos_sec_index][pos_pri_index] = esr2_fit_data[1]
                                        # update the ESR2 center frequency
                                        self.current_esr2_cntr_freq = esr2_fit_data[2]
                                elif len(esr2_fit_data) == 6:
                                    # print(
                                    #     '--> Find two ESR2 peaks, but only one is expected. No Fit is recorded.')
                                    if esr2_fit_data[1] < 0.5e6:

                                        print(
                                            '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print('--> Find two ESR2 peaks, only record the first peak info')
                                        # add to output structures which will be plotted

                                        self.data['esr2_fo'][pos_sec_index][pos_pri_index] = esr2_fit_data[5]
                                        self.data['esr2_wo'][pos_sec_index][pos_pri_index] = esr2_fit_data[1]
                                        self.data['esr2_ctrst'][pos_sec_index][pos_pri_index] = esr2_fit_data[3]
                                        # update the ESR2 center frequency
                                        self.current_esr2_cntr_freq = esr2_fit_data[5]

                            print('==================== Finished (Forward) =======================')
                            self.progress = index * 100. / (len(scan_pos_pri) * len(scan_pos_sec) * 2)
                            self.updateProgress.emit(int(self.progress))
                            index = index + 1
                        # the end of the forward primary loop
                        pass

                        # Backward Primary loop
                        for pos_pri_r_index in range(0, len(scan_pos_pri_r)):
                            if self._abort:
                                break
                            new_pos_pri_r = float(scan_pos_pri_r[pos_pri_r_index])
                            print('============= Start (index = ' + str(index) + ', Primary, Backward) ============')
                            print('------ Moving to Primary Position: ' + self.settings['scan_axis'][
                                0] + ' = {:0.2f} mm --------'.format(new_pos_pri_r))
                            # scan_instr_pri.update({'position': new_pos_pri_r})  # actually move the instrument to that location.
                            servo_move = scan_instr_pri._move_servo(new_pos_pri_r)
                            if not servo_move:
                                print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')

                            print('---------------- Tracking ----------------')
                            do_tracking(index)

                            # Do the actual measurements
                            print('---------------- Experiment ----------------')
                            if self.settings['exp_to_do']['fluorescence']:
                                fluor_data = self.meas_fluorescence(index=index)
                                # add to output structures which will be plotted
                                # self.data['counts'].append(np.mean(fluor_data))
                                self.data['counts_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = np.mean(fluor_data)
                            if self.settings['exp_to_do']['esr']:
                                esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                           self.settings['exp_settings']['esr_freq_range'],
                                                           label='esr1', index=index)

                                if esr_fit_data is None:
                                    print('--> No ESR fitting :(')
                                    # self.data['esr_fo'].append(0.0)
                                    # self.data['esr_wo'].append(0.0)

                                elif len(esr_fit_data) == 4:
                                    if esr_fit_data[3] < 0.5e6:
                                        # self.data['esr_fo'].append(0.0)
                                        # self.data['esr_wo'].append(0.0)
                                        print(
                                            '--> Find one ESR peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print(
                                            '--> Good, find one ESR peak :). fo = ' + str(
                                                esr_fit_data[2]) + ' Hz, wo = ' + str(
                                                esr_fit_data[3]) + 'Hz')
                                        # add to output structures which will be plotted
                                        # self.data['esr_fo'].append(esr_fit_data[2])
                                        # self.data['esr_wo'].append(esr_fit_data[3])
                                        self.data['esr_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr_fit_data[2]
                                        self.data['esr_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr_fit_data[3]
                                        self.data['esr_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr_fit_data[1]

                                        # update the ESR center frequency
                                        self.current_esr_cntr_freq = esr_fit_data[2]

                                elif len(esr_fit_data) == 6:
                                    # print(
                                    #     '--> Find two ESR peaks, but only one is expected. No Fit is recorded.')
                                    if esr_fit_data[1] < 0.5e6:

                                        print(
                                            '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print('--> Find two ESR peaks, only record the first peak info')
                                        # add to output structures which will be plotted

                                        self.data['esr_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr_fit_data[4]
                                        self.data['esr_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr_fit_data[1]
                                        self.data['esr_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr_fit_data[2]
                                        # update the ESR center frequency
                                        self.current_esr_cntr_freq = esr_fit_data[4]
                            if self.settings['exp_to_do']['esr2']:
                                esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                                                            self.settings['exp_settings']['esr2_freq_range'],
                                                            label='esr2', index=index)

                                if esr2_fit_data is None:
                                    print('--> No ESR2 fitting :(')
                                    # self.data['esr2_fo'].append(0.0)
                                    # self.data['esr2_wo'].append(0.0)
                                elif len(esr2_fit_data) == 4:
                                    if esr2_fit_data[3] < 0.5e6:
                                        # self.data['esr2_fo'].append(0.0)
                                        # self.data['esr2_wo'].append(0.0)
                                        print(
                                            '--> Find one ESR2 peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print('--> Good, find one ESR2 peak :). fo = ' + str(
                                            esr2_fit_data[2]) + ' Hz, wo = ' + str(
                                            esr2_fit_data[3]) + 'Hz')
                                        # add to output structures which will be plotted
                                        # self.data['esr2_fo'].append(esr2_fit_data[2])
                                        # self.data['esr2_wo'].append(esr2_fit_data[3])
                                        self.data['esr2_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr2_fit_data[
                                            2]
                                        self.data['esr2_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr2_fit_data[
                                            3]
                                        self.data['esr2_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr2_fit_data[
                                            1]
                                        # update the ESR2 center frequency
                                        self.current_esr2_cntr_freq = esr2_fit_data[2]
                                elif len(esr2_fit_data) == 6:
                                    # print(
                                    #     '--> Find two ESR2 peaks, but only one is expected. No Fit is recorded.')
                                    if esr2_fit_data[1] < 0.5e6:
                                        # self.data['esr2_fo'].append(0.0)
                                        # self.data['esr2_wo'].append(0.0)
                                        print(
                                            '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print('--> Find two ESR2 peaks, only record the first peak info')
                                        # add to output structures which will be plotted
                                        # self.data['esr2_fo'].append(esr2_fit_data[4])
                                        # self.data['esr2_wo'].append(esr2_fit_data[1])
                                        self.data['esr2_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr2_fit_data[
                                            5]
                                        self.data['esr2_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr2_fit_data[
                                            1]
                                        self.data['esr2_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                                        esr2_fit_data[
                                            3]
                                        # update the ESR2 center frequency
                                        self.current_esr2_cntr_freq = esr2_fit_data[5]

                            print('==================== Finished (Backward) =======================')
                            self.progress = index * 100. / (len(scan_pos_pri) * len(scan_pos_sec) * 2)
                            self.updateProgress.emit(int(self.progress))
                            index = index + 1
                        # the end of the backward primary loop
                        pass

                        print('★★★★★★★★★★★★★★★★★★  Finished (Secondary) ★★★★★★★★★★★★★★★★★★')

                    # the end of the 2D sweep
                    pass

    def _plot(self, axes_list, data=None):
        # COMMENT_ME

        if data is None:
            data = self.data
        if self.settings['scan_axis'] in ['x', 'y', 'z'] and self.settings['to-do'] == 'sweep':
            print('(1D plot)')
            if self.data['counts'] is not None:
                lbls1 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]',
                         'counts [kcps]', 'Fluorescence']
                plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['positions'], np.array(self.data['counts']),
                                          lbls1, x_r=self.data['positions_r'], y1_r=np.array(self.data['counts_r']))

            if self.settings['exp_settings']['to_plot'] ==  'contrast': # to plot contrast
                if self.data['esr_fo'] is not None and self.data['esr_ctrst'] is not None:
                    lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                             'contrast', 'ESR']
                    plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                            np.array(self.data['esr_fo']),
                                            np.array(self.data['esr_ctrst']), lbls2, x_r=self.data['positions_r'],
                                            y1_r=np.array(self.data['esr_fo_r']), y2_r=np.array(self.data['esr_ctrst_r']))
                if self.data['esr2_fo'] is not None and self.data['esr2_ctrst'] is not None:
                    lbls3 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                             'contrast', 'ESR 2']
                    plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'],
                                            np.array(self.data['esr2_fo']),
                                            np.array(self.data['esr2_ctrst']), lbls3, x_r=self.data['positions_r'],
                                            y1_r=np.array(self.data['esr2_fo_r']), y2_r=np.array(self.data['esr2_ctrst_r']))
            else:
                if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                    lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                             'wo[Hz]', 'ESR']
                    plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                            np.array(self.data['esr_fo']),
                                            np.array(self.data['esr_wo']), lbls2, x_r=self.data['positions_r'],
                                            y1_r=np.array(self.data['esr_fo_r']), y2_r=np.array(self.data['esr_wo_r']))
                if self.data['esr2_fo'] is not None and self.data['esr2_wo'] is not None:
                    lbls3 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                             'wo[Hz]', 'ESR 2']
                    plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'],
                                            np.array(self.data['esr2_fo']),
                                            np.array(self.data['esr2_wo']), lbls3, x_r=self.data['positions_r'],
                                            y1_r=np.array(self.data['esr2_fo_r']), y2_r=np.array(self.data['esr2_wo_r']))

        elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz'] and self.settings['to-do'] == 'sweep':
            print('(2D plot)')
            if self.data['counts'] is not None:
                plot_magnet_sweep2D_Fluor(data['counts'], data['bounds'], axes_list[0], axes_labels=self.settings['scan_axis'], title = 'Fluor Forward', colorbar_name = 'kcps')
            if self.data['counts_r'] is not None:
                plot_magnet_sweep2D_Fluor(data['counts_r'], data['bounds'], axes_list[2], axes_labels=self.settings['scan_axis'], title = 'Fluor Backward', colorbar_name = 'kcps')
            if self.data['esr_fo'] is not None:
                plot_magnet_sweep2D_Fluor(data['esr_fo']/1e6, data['bounds'], axes_list[3], axes_labels=self.settings['scan_axis'], title = 'ESR Forward', colorbar_name = 'MHz')
            if self.data['esr_fo_r'] is not None:
                plot_magnet_sweep2D_Fluor(data['esr_fo_r']/1e6, data['bounds'], axes_list[4], axes_labels=self.settings['scan_axis'], title = 'ESR Backward', colorbar_name = 'MHz')
            # elif self.data['esr_wo'] is not None:
            #     plot_magnet_sweep2D_Fluor(data['esr_wo']/1e6, data['bounds'], axes_list[4], axes_labels=self.settings['scan_axis'], title = 'ESR width Forward', colorbar_name = 'MHz')
            if self.data['esr2_fo'] is not None:
                plot_magnet_sweep2D_Fluor(data['esr2_fo']/1e6, data['bounds'], axes_list[5], axes_labels=self.settings['scan_axis'], title = 'ESR2 Forward', colorbar_name = 'MHz')
            if self.data['esr2_fo_r'] is not None:
                plot_magnet_sweep2D_Fluor(data['esr2_fo_r']/1e6, data['bounds'], axes_list[6], axes_labels=self.settings['scan_axis'], title = 'ESR2 Backward', colorbar_name = 'MHz')
            # elif self.data['esr2_wo'] is not None:
            #     plot_magnet_sweep2D_Fluor(data['esr2_wo']/1e6, data['bounds'], axes_list[6], axes_labels=self.settings['scan_axis'], title = 'ESR2 width Forward', colorbar_name = 'MHz')

    def _update_plot(self, axes_list):

        # print('_update_plot')

        if self._current_subscript_stage['current_subscript'] is self.scripts['daq_read_counter'] and self.scripts['daq_read_counter'].is_running:
            self.scripts['daq_read_counter']._plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['esr'] and self.scripts['esr'].is_running:
            # print('updating esr plot now')
            self.scripts['esr']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['find_nv'] and self.scripts['find_nv'].is_running:
            if self.flag_find_nv_plot:
                # print('self.flag_find_nv_plot is', self.flag_find_nv_plot)
                self.scripts['find_nv']._plot([axes_list[1]], colorbar=0) # this is to remove colorbar
                self.flag_find_nv_plot = False
            else:
                self.scripts['find_nv']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['optimize_z'] and self.scripts['optimize_z'].is_running:
            # print('optimize_z is running, update plot')
            if self.flag_optimize_z_plot:
                self.scripts['optimize_z']._plot([axes_list[1]])
                self.flag_optimize_z_plot = False
            else:
                self.scripts['optimize_z']._update_plot ([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['autofocus'] and self.scripts['autofocus'].is_running:
            # print('autofocus is running, update plot')
            if self.flag_autofocus_plot:
                # print('self.flag_autofocus_plot is', self.flag_autofocus_plot)
                self.scripts['autofocus']._plot([axes_list[0], axes_list[1]], colorbar=0)
                self.flag_autofocus_plot = False
                self.flag_image0_update_plot = False
            else:
                self.scripts['autofocus']._update_plot([axes_list[0], axes_list[1]])
                self.flag_image0_update_plot = False
        else:
            if self.settings['scan_axis'] in ['x', 'y', 'z'] and self.settings['to-do'] == 'sweep':
                print('(updating 1D plot)')

                if self.data['counts'] is not None:
                    lbls1 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]',
                             'counts [kcps]', 'Fluorescence']
                    plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['positions'], np.array(self.data['counts']),
                                              lbls1, x_r=self.data['positions_r'], y1_r=np.array(self.data['counts_r']))
                if self.settings['exp_settings']['to_plot'] == 'contrast':  # to plot contrast
                    if self.data['esr_fo'] is not None and self.data['esr_ctrst'] is not None:
                        lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                                 'contrast', 'ESR']
                        plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                                np.array(self.data['esr_fo']),
                                                np.array(self.data['esr_ctrst']), lbls2, x_r=self.data['positions_r'],
                                                y1_r=np.array(self.data['esr_fo_r']),
                                                y2_r=np.array(self.data['esr_ctrst_r']))
                    if self.data['esr2_fo'] is not None and self.data['esr2_ctrst'] is not None:
                        lbls3 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                                 'contrast', 'ESR 2']
                        plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'],
                                                np.array(self.data['esr2_fo']),
                                                np.array(self.data['esr2_ctrst']), lbls3, x_r=self.data['positions_r'],
                                                y1_r=np.array(self.data['esr2_fo_r']),
                                                y2_r=np.array(self.data['esr2_ctrst_r']))
                else: # to plot width
                    if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                        lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                                 'wo[Hz]', 'ESR']
                        plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                                np.array(self.data['esr_fo']),
                                                np.array(self.data['esr_wo']), lbls2, x_r=self.data['positions_r'],
                                                y1_r=np.array(self.data['esr_fo_r']),
                                                y2_r=np.array(self.data['esr_wo_r']))
                    if self.data['esr2_fo'] is not None and self.data['esr2_wo'] is not None:
                        lbls3 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                                 'wo[Hz]', 'ESR 2']
                        plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'],
                                                np.array(self.data['esr2_fo']),
                                                np.array(self.data['esr2_wo']), lbls3, x_r=self.data['positions_r'],
                                                y1_r=np.array(self.data['esr2_fo_r']),
                                                y2_r=np.array(self.data['esr2_wo_r']))

            elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz'] and self.settings['to-do'] == 'sweep':
                print('(updating 2D plot)')
                if self.data['counts'] is not None:
                    if self.flag_image0_update_plot:
                        update_magnet_sweep2D_Fluor(self.data['counts'], axes_list[0])
                    else:
                        plot_magnet_sweep2D_Fluor(self.data['counts'], self.data['bounds'], axes_list[0],
                                                  axes_labels=self.settings['scan_axis'], title='Fluor Forward',
                                                  colorbar_name='kcps')
                        self.flag_image0_update_plot = True
                if self.data['counts_r'] is not None:
                    update_magnet_sweep2D_Fluor(self.data['counts_r'],axes_list[2])
                if self.data['esr_fo'] is not None:
                    update_magnet_sweep2D_Fluor(self.data['esr_fo']/1e6, axes_list[3])
                if self.data['esr_fo_r'] is not None:
                    update_magnet_sweep2D_Fluor(self.data['esr_fo_r']/1e6, axes_list[4])
                if self.data['esr2_fo'] is not None:
                    update_magnet_sweep2D_Fluor(self.data['esr2_fo']/1e6, axes_list[5])
                if self.data['esr2_fo_r'] is not None:
                    update_magnet_sweep2D_Fluor(self.data['esr2_fo_r']/1e6, axes_list[6])

    def get_axes_layout(self, figure_list):
        """
        returns the axes objects the script needs to plot its data
        this overwrites the default get_axis_layout in PyLabControl.src.core.scripts
        Args:
            figure_list: a list of figure objects
        Returns:
            axes_list: a list of axes objects

        """
        axes_list = []
        if self.settings['scan_axis'] in ['x', 'y', 'z']:
            if self._plot_refresh is True:
                for fig in figure_list:
                    fig.clf()
                # 5 subplots in total
                axes_list.append(figure_list[0].add_subplot(131))  # axes_list[0]
                axes_list.append(figure_list[1].add_subplot(111))  # axes_list[1]
                axes_list.append(figure_list[0].add_subplot(232))  # axes_list[2]
                axes_list.append(figure_list[0].add_subplot(235))  # axes_list[3]
                axes_list.append(figure_list[0].add_subplot(233))  # axes_list[4]
                axes_list.append(figure_list[0].add_subplot(236))  # axes_list[5]

            else:
                axes_list.append(figure_list[0].axes[0])
                axes_list.append(figure_list[1].axes[0])
                axes_list.append(figure_list[0].axes[1])
                axes_list.append(figure_list[0].axes[2])
                axes_list.append(figure_list[0].axes[3])
                axes_list.append(figure_list[0].axes[4])

            return axes_list

        elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz']:
            if self._plot_refresh is True:
                for fig in figure_list:
                    fig.clf()
                # 6 subplots in total
                axes_list.append(figure_list[0].add_subplot(231))  # axes_list[0]
                axes_list.append(figure_list[1].add_subplot(111))  # axes_list[1]
                axes_list.append(figure_list[0].add_subplot(234))  # axes_list[2]
                axes_list.append(figure_list[0].add_subplot(232))  # axes_list[3]
                axes_list.append(figure_list[0].add_subplot(235))  # axes_list[4]
                axes_list.append(figure_list[0].add_subplot(233))  # axes_list[5]
                axes_list.append(figure_list[0].add_subplot(236))  # axes_list[6]

            else:
                axes_list.append(figure_list[0].axes[0])
                axes_list.append(figure_list[1].axes[0])
                axes_list.append(figure_list[0].axes[1])
                axes_list.append(figure_list[0].axes[2])
                axes_list.append(figure_list[0].axes[3])
                axes_list.append(figure_list[0].axes[4])
                axes_list.append(figure_list[0].axes[5])

            return axes_list

class MagnetSweep1DAdv(Script):
    """
        MagnetSweep1D sweeps the position of the automatic translation stages, in 1D or 2D scans, and does the following experiments:
        (1) NV fluorescence
        (2) ESR
        (3) Rabi (optional)
        (4) Periodic Dynamical Decoupling - PDD (optional)
        (5) Ramsey (optional)
        For the optional scripts, set the right parameters in the subscripts.
        Note that only 1D scan is allowed, and only 1 ESR can be done.
        --> Last edited by ZQ 9/17/2019
    """

    _DEFAULT_SETTINGS = [
        Parameter('to-do', 'read', ['initialize', 'move', 'sweep', 'read'], 'Choose to move to a point, do a magnet sweep or just read the magnet positions'),
        Parameter('servo_initial',
                  [Parameter('initialize', True, bool,
                             'whether or not to intialize the servo position before sweeping? (highly recommended)'),
                   Parameter('Xservo', 9.0, float, 'initial position of Xservo'),
                   Parameter('Yservo', 4.0, float, 'initial position of Yservo'),
                   Parameter('Zservo', 5.0, float, 'initial position of Zservo'),
                   Parameter('moving_velocity', 0.5, float, 'servo moving velocity (mm/s)'),
                   Parameter('Xservo_min', 0.0, float, 'minimum allowed position of Xservo'),
                   Parameter('Xservo_max', 23.0, float, 'maximum allowed position of Xservo'),
                   Parameter('Yservo_min', 0.0, float, 'minimum allowed position of Yservo'),
                   Parameter('Yservo_max', 13.0, float, 'maximum allowed position of Yservo'),
                   Parameter('Zservo_min', 3.0, float, 'minimum allowed position of Zservo'),
                   Parameter('Zservo_max', 25.0, float, 'maximum allowed position of Zservo'),
                   ]),

        # Parameter('scan_axis', 'xy', ['xy', 'yx', 'xz', 'zx', 'yz', 'zy', 'x', 'y', 'z'],
        #           'Choose 2D or 1D magnet sweep to perform'),
        Parameter('scan_axis', 'x', ['x', 'y', 'z'],
                  'Choose which axis to perform 1D magnet sweep'),
        Parameter('move_to',
                  [Parameter('x', 15.0, float, 'move to x-coordinate [mm]'),
                   Parameter('y', 10.0, float, 'move to y-coordinate [mm]'),
                   Parameter('z', 10.0, float, 'move to z-coordinate [mm]')
                   ]),
        Parameter('sweep_center',
                  [Parameter('x', 15.0, float, 'x-coordinate [mm] of the sweep center'),
                   Parameter('y', 10.0, float, 'y-coordinate [mm] of the sweep center'),
                   Parameter('z', 5.0, float, 'z-coordinate [mm] of the sweep center')
                   ]),
        Parameter('sweep_span',
                  [Parameter('x', 3.0, float, 'x-coordinate [mm]'),
                   Parameter('y', 0.0, float, 'y-coordinate [mm]'),
                   Parameter('z', 0.0, float, 'z-coordinate [mm]')
                   ]),
        Parameter('num_points',
                  [Parameter('x', 15, int, 'number of x points to scan'),
                   Parameter('y', 0, int, 'number of y points to scan'),
                   Parameter('z', 0, int, 'number of z points to scan')
                   ]),
        Parameter('exp_to_do', [Parameter('backward_sweep', False, bool, 'whether to do a backward sweep'),
                                Parameter('fluorescence', True, bool, 'measure the NV fluorescence'),
                                Parameter('esr', True, bool, 'measure the ESR of NV'),
                                # Parameter('esr2', False, bool,
                                #           'measure the ESR of NV at two different frequencies'), # disabled for this script
                                Parameter('Rabi', True, bool, 'measure Rabi at the ESR resonance frequency'),
                                Parameter('PDD', True, bool, 'measure T2 coherence times using dynamical decoupling'),
                                Parameter('Ramsey', False, bool, 'measure Ramsey')]),
        Parameter('exp_settings', [
            Parameter('intensity_wheel_esr', 298, float, 'microwave power for ESR scan'),
            Parameter('intensity_wheel_pulse', 260, float, 'minimum number of esr averages'),
            Parameter('fluorescence_time_per_pt', 0.4, float, 'time for fluorescence measurement at each point (s)'),
            Parameter('esr_mw_pwr', -10, float, 'microwave power for ESR scan'),
            Parameter('esr_avg_min', 12, int, 'minimum number of esr averages'),
            Parameter('esr_avg_max', 50, int, 'maximum number of esr averages'),
            Parameter('esr_cntr_freq', 2.82e9, float, 'center frequency for ESR scan'),
            Parameter('esr_freq_range', 8.5e7, float, 'frequency range for ESR scan (suggest 6e7 - 9e7)'),
            Parameter('esr2_cntr_freq', 2.99e9, float, 'center frequency for the second ESR scan'),
            Parameter('esr2_freq_range', 8.5e7, float, 'frequency range for the second ESR scan(suggest 6e7 - 9e7)'),
            Parameter('esr_ini_stab_time', 1, int, 'laser power stabilization time (sec)'),
            Parameter('esr_num_of_pts', 150, int, 'number of frequency points for ESR scan'),
            Parameter('esr_time_per_pt', 0.02, [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1],
                      'integration time for each point in the fast ESR scan (suggest 0.02-0.04)'),
            Parameter('esrfit_num_of_peaks', 1, [-1, 1, 2],
                      'specify number of peaks for fitting. if not specifying the number of peaks, choose -1'),
            Parameter('esrfit_minimum_counts', 0.9, float,
                      'minumum counts for an ESR to not be considered noise (suggest 0.8 - 1.01 if esr is normalized)'),
            Parameter('esrfit_contrast_factor', 3.0, float,
                      'minimum contrast for an ESR to not be considered noise (suggest 3.0-4.0)'),
            Parameter('to_plot', 'fwhm', ['fwhm', 'contrast'], 'choose to plot fwhm or contrast in 1D sweep')
        ]),
        Parameter('tracking_settings', [Parameter('track_focus', 'optimize_z', ['optimize_z', 'autofocus', 'None'],
                                                  'choose the method for tracking (optimize_z is recommended)'),
                                        Parameter('track_focus_every_N', 5, int, 'track every N points'),
                                        Parameter('track_to_nv', True, bool,
                                                  'check to use find_nv to track to the NV'),
                                        Parameter('track_to_nv_every_N', 1, int, 'track every N points'),
                                        Parameter('track_frequency', True, bool,
                                                  'keep track of the frequency and set it to the central frequency of the next ESR scan (recommended)'),
                                        Parameter('track_frequency_every_N', 1, int, 'track every N points')]),
        Parameter('optimize_z_settings', [Parameter('sweep_range', 0.5, float, 'z voltage range for optimizing scan (suggest 0.6)'),
                                          Parameter('num_points', 36, int, 'number of z points to scan (suggest 41)'),
                                          ]),
        Parameter('autofocus_settings', [Parameter('scan_width', 0.6, float, 'z voltage range for optimizing scan (suggest 0.6-0.9)'),
                                         Parameter('num_sweep_points', 6, int,
                                                   'number of values to sweep between min and max voltage (suggest 6-10)'),
                                         ]),
        Parameter('find_nv_settings',
                  [Parameter('sweep_range', 0.37, float, 'voltage range to sweep over to find a max (suggest 0.4)'),
                   Parameter('num_points', 61, int, 'number of points to sweep in the sweep range'),
                   Parameter('nv_size', 21, int,
                             'size of nv in pixels - need to be refined!! needs to be odd number!!!'),
                   Parameter('min_mass', 80, int, 'TEMP: brightness of nv - need to be refined!! (suggest 60-100)'),
                   ])
    ]

    _INSTRUMENTS = {'XServo': MagnetX, 'YServo': MagnetY, 'ZServo': MagnetZ,
                    'mw_gen': R8SMicrowaveGenerator}

    _SCRIPTS = {'find_nv': FindNV, 'daq_read_counter': Daq_Read_Counter, 'esr': ESR_FastSwp_RnS_FitGuaranteed,
                'autofocus': AutoFocusDAQ, 'optimize_z': optimize, 'rabi': Rabi_N9310A, 'ramsey': Ramsey_N9310A,
                'pdd': PDD_XYreadout, 'wheel':IntensityWheel_Calibration}

    def __init__(self, instruments = None, scripts = None, name = None, settings = None, log_function = None, data_path = None):
        """
        Example of a script that makes use of an instrument
        Args:
            instruments: instruments the script will make use of
            name (optional): name of script, if empty same as class name
            settings (optional): settings for this script, if empty same as default settings
        """

        # call init of superclass
        Script.__init__(self, name, settings=settings, instruments=instruments, scripts=scripts,
                        log_function=log_function, data_path=data_path)

    def _get_instr(self):
        """
        Assigns an instrument relevant to the 1D scan axis.
        """
        if self.settings['scan_axis'] == 'x':
            return self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'y':
            return self.instruments['YServo']['instance']
        elif self.settings['scan_axis'] == 'z':
            return self.instruments['ZServo']['instance']

    def _get_instr_2D(self):
        """
        Assigns an instrument relevant to the 2D scan axis.
        """
        if self.settings['scan_axis'] == 'xy':
            return self.instruments['XServo']['instance'], self.instruments['YServo']['instance']
        elif self.settings['scan_axis'] == 'yx':
            return self.instruments['YServo']['instance'], self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'xz':
            return self.instruments['XServo']['instance'], self.instruments['ZServo']['instance']
        elif self.settings['scan_axis'] == 'zx':
            return self.instruments['ZServo']['instance'], self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'yz':
            return self.instruments['YServo']['instance'], self.instruments['ZServo']['instance']
        elif self.settings['scan_axis'] == 'zy':
            return self.instruments['ZServo']['instance'], self.instruments['YServo']['instance']

    def _get_scan_positions(self, verbose=True):
        '''
        Returns an array of points to go to in the 1D scan.
        '''
        if self.settings['scan_axis'] in ['x', 'y', 'z']:
            min_pos = self.settings['sweep_center'][self.settings['scan_axis']] - 0.5 * self.settings['sweep_span'][
                self.settings['scan_axis']]

            max_pos = self.settings['sweep_center'][self.settings['scan_axis']] + 0.5 * self.settings['sweep_span'][
                self.settings['scan_axis']]
            num_points = self.settings['num_points'][self.settings['scan_axis']]
            scan_pos = [np.linspace(min_pos, max_pos, num_points)]
            if verbose:
                print('-------------Scan Settings---------------')
                print('Scan axis:' + self.settings['scan_axis'])
                print('Values for the primary scan are (in mm):' + self.settings['scan_axis'] + ' = ', scan_pos)

            return scan_pos
        else:
            print('NotImplementedError: multiple dimensional scans not yet implemented')
            NotImplementedError('multiple dimensional scans not yet implemented')

    def _get_scan_positions_2D(self, verbose=True):
        if self.settings['scan_axis'] in ['xy', 'yx', 'xz', 'zx', 'yz', 'zy']:
            # print('for calculating primary positions:')
            # print(self.settings['sweep_center'][self.settings['scan_axis'][0]])
            # print(self.settings['sweep_span'][
            #           self.settings['scan_axis'][0]])
            # print('for calculating secondary positions:')
            # print(self.settings['sweep_center'][self.settings['scan_axis'][1]])
            # print(self.settings['sweep_span'][
            #           self.settings['scan_axis'][1]])

            primary_min_pos = self.settings['sweep_center'][self.settings['scan_axis'][0]] - self.settings['sweep_span'][
                self.settings['scan_axis'][0]]/2.0

            primary_max_pos = self.settings['sweep_center'][self.settings['scan_axis'][0]] +  self.settings['sweep_span'][
                self.settings['scan_axis'][0]]/2.0
            primary_num_points = self.settings['num_points'][self.settings['scan_axis'][0]]
            secondary_min_pos = self.settings['sweep_center'][self.settings['scan_axis'][1]] - self.settings['sweep_span'][self.settings['scan_axis'][1]]/2.0
            secondary_max_pos = self.settings['sweep_center'][self.settings['scan_axis'][1]] + self.settings['sweep_span'][self.settings['scan_axis'][1]]/2.0
            secondary_num_points = self.settings['num_points'][self.settings['scan_axis'][1]]

            primary_scan_pos = np.linspace(primary_min_pos, primary_max_pos, num = primary_num_points)
            secondary_scan_pos = np.linspace(secondary_min_pos, secondary_max_pos, num = secondary_num_points)

            if verbose:
                print('-------------Scan Settings---------------')
                print('Scan axis:' + self.settings['scan_axis'])
                # print('primary_min_pos',primary_min_pos)
                # print('primary_max_pos',primary_max_pos )
                # print('secondary_min_pos',secondary_min_pos )
                # print('secondary_max_pos', secondary_max_pos)
                print('Values for the primary scan are (in mm): ' + self.settings['scan_axis'][0] + ' = ', primary_scan_pos)
                print('Values for the secondary scan are (in mm): ' + self.settings['scan_axis'][1] + ' = ', secondary_scan_pos)
            return primary_scan_pos, secondary_scan_pos

        else:
            print('NotImplementedError: dimension is not right.')
            NotImplementedError('Dimension is not right')

    @staticmethod
    def pts_to_extent(pta, ptb):
        """
        Args:
            pta: point a
            ptb: point b
            roi_mode:   mode how to calculate region of interest
                        corner: pta and ptb are diagonal corners of rectangle.
                        center: pta is center and ptb is extend or rectangle

        Returns: extend of region of interest [xVmin, xVmax, yVmax, yVmin]
        """
        xVmin = pta['x'] - float(ptb['x']) / 2.
        xVmax = pta['x'] + float(ptb['x']) / 2.
        yVmin = pta['y'] - float(ptb['y']) / 2.
        yVmax = pta['y'] + float(ptb['y']) / 2.
        zVmin = pta['z'] - float(ptb['z']) / 2.
        zVmax = pta['z'] + float(ptb['z']) / 2.

        return [xVmin, xVmax, yVmin, yVmax, zVmin, zVmax]

    def meas_fluorescence(self, index = -1):

        # update the tag of the daq_read_counter script
        if index >= 0:
            self.scripts['daq_read_counter'].settings['tag'] = 'daq_read_counter_ind' + str(index)


        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_esr']
        self.scripts['wheel'].run()

        # run daq_read_counter or the relevant script to get fluorescence
        print('==> Start measuring FLUORESCENCE...')
        self.scripts['daq_read_counter'].run()
        time.sleep(self.settings['exp_settings']['fluorescence_time_per_pt'])
        self.scripts['daq_read_counter'].stop()
        data = self.scripts['daq_read_counter'].data['counts']
        print('--> Mean counts = {:0.2f} kcps'.format(np.mean(data)))
        return data

    def do_esr(self, esr_cntr_freq, esr_freq_range, label = None, index = -1, verbose=False):

        # update the tag of the esr script
        if label is not None and index >= 0:
            self.scripts['esr'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['esr'].settings['tag'] = label
        elif index >= 0:
            self.scripts['esr'].settings['tag'] = 'esr_ind' + str(index)

        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_esr']
        self.scripts['wheel'].run()

        # set the right parameters for the ESR scan
        self.scripts['esr'].settings['power_out'] = self.settings['exp_settings']['esr_mw_pwr']
        self.scripts['esr'].settings['esr_avg_min'] = self.settings['exp_settings']['esr_avg_min']
        self.scripts['esr'].settings['esr_avg_max'] = self.settings['exp_settings']['esr_avg_max']
        self.scripts['esr'].settings['freq_start'] = float(esr_cntr_freq)
        self.scripts['esr'].settings['freq_stop'] = float(esr_freq_range)
        self.scripts['esr'].settings['range_type'] = 'center_range'
        self.scripts['esr'].settings['freq_points'] = self.settings['exp_settings']['esr_num_of_pts']
        self.scripts['esr'].settings['ini_stab_time'] = self.settings['exp_settings']['esr_ini_stab_time']
        self.scripts['esr'].settings['time_per_pt'] = self.settings['exp_settings']['esr_time_per_pt']
        self.scripts['esr'].settings['fit_constants']['num_of_peaks'] = self.settings['exp_settings'][
            'esrfit_num_of_peaks']
        self.scripts['esr'].settings['fit_constants']['minimum_counts'] = self.settings['exp_settings'][
            'esrfit_minimum_counts']
        self.scripts['esr'].settings['fit_constants']['contrast_factor'] = self.settings['exp_settings'][
            'esrfit_contrast_factor']
        print('==> Start measuring ESR...')
        self.scripts['esr'].run()
        esr_fit_data = self.scripts['esr'].data['fit_params']
        if verbose:
            print('len(esr_fit_data) =  ', esr_fit_data)

        return esr_fit_data

    def do_rabi(self, mw_freq, label = None, index = -1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['rabi'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['rabi'].settings['tag'] = label
        elif index >= 0:
            self.scripts['rabi'].settings['tag'] = 'rabi_ind' + str(index)

        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_pulse']
        self.scripts['wheel'].run()

        # set the right parameters for the Rabi
        self.scripts['rabi'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        print('==> Start measuring Rabi...')
        self.scripts['rabi'].run()

        if 'fits' in self.scripts['rabi'].data.keys() and self.scripts['rabi'].data['fits'] is not None:
            Rabi_Success = True
            pi_time = self.scripts['rabi'].data['pi_time']
            pi_half_time = self.scripts['rabi'].data['pi_half_time']
            three_pi_half_time = self.scripts['rabi'].data['three_pi_half_time']
            mw_power = self.scripts['rabi'].settings['mw_pulses']['mw_power']
        else:
            Rabi_Success = False
            pi_time = -1.0
            pi_half_time = -1.0
            three_pi_half_time = -1.0
            mw_power = self.scripts['rabi'].settings['mw_pulses']['mw_power']

        return Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time

    def do_ramsey(self, mw_power, mw_freq, pi_half_time, three_pi_half_time, label=None, index=-1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['ramsey'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['ramsey'].settings['tag'] = label
        elif index >= 0:
            self.scripts['ramsey'].settings['tag'] = 'rabi_ind' + str(index)


        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_pulse']
        self.scripts['wheel'].run()

        # set the right parameters for the Ramsey
        self.scripts['ramsey'].settings['mw_pulses']['mw_power'] = float(mw_power)
        self.scripts['ramsey'].settings['mw_pulses']['resonant_freq'] = float(mw_freq)
        self.scripts['ramsey'].settings['mw_pulses']['pi_half_pulse_time'] = float(pi_half_time)
        self.scripts['ramsey'].settings['mw_pulses']['three_pi_half_pulse_time'] = float(three_pi_half_time)

        print('==> Start measuring Ramsey...')
        self.scripts['ramsey'].run()

    def do_pdd(self, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label=None, index=-1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['pdd'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['pdd'].settings['tag'] = label
        elif index >= 0:
            self.scripts['pdd'].settings['tag'] = 'rabi_ind' + str(index)

        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_pulse']
        self.scripts['wheel'].run()

        # set the right parameters for PDD
        self.scripts['pdd'].settings['mw_pulses']['mw_power'] = float(mw_power)
        self.scripts['pdd'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        self.scripts['pdd'].settings['mw_pulses']['pi_pulse_time'] = float(pi_time)
        self.scripts['pdd'].settings['mw_pulses']['pi_half_pulse_time'] = float(pi_half_time)
        self.scripts['pdd'].settings['mw_pulses']['3pi_half_pulse_time'] = float(three_pi_half_time)

        print('==> Start measuring PDD...')
        self.scripts['pdd'].run()

    def _function(self):
        self.flag_image0_update_plot = True
        # self.settings['exp_to_do']['esr2'] = False # disable doing ESR2 experiment now
        if self.settings['exp_to_do']['Rabi']: # if Rabi is selected, set peak # to be 1.
            self.settings['exp_settings']['esrfit_num_of_peaks'] = 1

        def set_tracking_parameters():
            # set the parameters for all the scripts
            # optimize_z settings
            self.scripts['optimize_z'].update({'optimizing_x': False})
            self.scripts['optimize_z'].update({'optimizing_y': False})
            self.scripts['optimize_z'].update({'optimizing_z': True})
            self.scripts['optimize_z'].settings['sweep_range'].update(
                {'z': self.settings['optimize_z_settings']['sweep_range']})
            self.scripts['optimize_z'].settings['num_points'].update(
                {'z': self.settings['optimize_z_settings']['num_points']})
            # find_nv settings
            self.scripts['find_nv'].update({'center_on_current_location': True})
            self.scripts['find_nv'].update({'sweep_range': self.settings['find_nv_settings']['sweep_range']})
            self.scripts['find_nv'].update({'num_points': self.settings['find_nv_settings']['num_points']})
            self.scripts['find_nv'].update({'nv_size': self.settings['find_nv_settings']['nv_size']})
            self.scripts['find_nv'].update({'min_mass': self.settings['find_nv_settings']['min_mass']})
            # autofocus settings
            self.scripts['autofocus'].update({'scan_width': self.settings['autofocus_settings']['scan_width']})
            self.scripts['autofocus'].update(
                {'num_sweep_points': self.settings['autofocus_settings']['num_sweep_points']})
            self.scripts['autofocus'].scripts['take_image'].settings['num_points'].update({'x': 51})
            self.scripts['autofocus'].scripts['take_image'].settings['num_points'].update({'y': 51})

        def do_tracking(index):

            # update the tag of scripts
            if index >= 0:
                self.scripts['find_nv'].settings['tag'] = 'find_nv_ind' + str(index)
                self.scripts['optimize_z'].settings['tag'] = 'optimize_z_ind' + str(index)
                self.scripts['autofocus'].settings['tag'] = 'autofocus_ind' + str(index)

            # track to the NV if it's time to
            if self.settings['tracking_settings']['track_focus'] != 'None':
                if index > 0 and index % self.settings['tracking_settings']['track_focus_every_N'] == 0:
                    print('==> Do track_focus now:')
                    if self.settings['tracking_settings']['track_focus'] == 'optimize_z':
                        print('    ==> optimize_z starts')
                        self.flag_optimize_z_plot = True
                        self.scripts['optimize_z'].run()
                        self.flag_find_nv_plot = True
                        print('==> find_NV starts (after tracking focus)')
                        self.scripts['find_nv'].run()

                    elif self.settings['tracking_settings']['track_focus'] == 'autofocus':
                        print('    ==> autofocus starts')
                        self.flag_autofocus_plot = True
                        self.scripts['autofocus'].run()

                        print('==> find_NV starts (after tracking focus)')
                        self.flag_find_nv_plot = True
                        self.scripts['find_nv'].run()
            if self.settings['tracking_settings']['track_to_nv']:
                # if index > 0 and index % self.settings['tracking_settings']['track_to_nv_every_N'] == 0 & index % self.settings['tracking_settings']['track_focus_every_N'] != 0:
                if index == 0 or index % self.settings['tracking_settings']['track_to_nv_every_N'] == 0:
                    self.flag_find_nv_plot = True
                    print('==> find_NV starts')
                    self.scripts['find_nv'].run()
            if self.settings['tracking_settings']['track_frequency']:
                if index > 0 and index % self.settings['tracking_settings']['track_frequency_every_N'] == 0:
                    print('==> track_frequency')
                    self.esr_cntr_freq_todo = self.current_esr_cntr_freq
                    self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

        if self.settings['to-do'] == 'read':
            Zservo_position = self.instruments['ZServo']['instance']._get_position()
            Zservo_velocity = self.instruments['ZServo']['instance']._get_velocity()
            self.log('MagnetZ position: ' + str(Zservo_position) + 'mm, velocity = ' + str(Zservo_velocity) + 'mm/s')
            Yservo_position = self.instruments['YServo']['instance']._get_position()
            Yservo_velocity = self.instruments['YServo']['instance']._get_velocity()
            self.log('MagnetY position: ' + str(Yservo_position) + 'mm, velocity = ' + str(Yservo_velocity) + 'mm/s')
            Xservo_position = self.instruments['XServo']['instance']._get_position()
            Xservo_velocity = self.instruments['XServo']['instance']._get_velocity()
            self.log('MagnetX position: ' + str(Xservo_position) + 'mm, velocity = ' + str(Xservo_velocity) + 'mm/s')

        else:
            # initialize the servo positions
            if self.settings['servo_initial']['initialize'] or self.settings['to-do'] == 'initialize':
                print('----------- Servo Initialization -----------')
                print('Xservo:')
                self.instruments['XServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Xservo_min']})
                self.instruments['XServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Xservo_max']})
                self.instruments['XServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['XServo']['instance'].update({'position': self.settings['servo_initial']['Xservo']})
                servo_move = self.instruments['XServo']['instance']._move_servo(self.settings['servo_initial']['Xservo'])
                if not servo_move:
                    print('Xservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True

                print('Yservo:')
                self.instruments['YServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Yservo_min']})
                self.instruments['YServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Yservo_max']})
                self.instruments['YServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['YServo']['instance'].update({'position': self.settings['servo_initial']['Yservo']})
                servo_move = self.instruments['YServo']['instance']._move_servo(self.settings['servo_initial']['Yservo'])
                if not servo_move:
                    print('Yservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True


                print('Zservo:')
                self.instruments['ZServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Zservo_min']})
                self.instruments['ZServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Zservo_max']})
                self.instruments['ZServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['ZServo']['instance'].update({'position': self.settings['servo_initial']['Zservo']})
                servo_move = self.instruments['ZServo']['instance']._move_servo(self.settings['servo_initial']['Zservo'])
                if not servo_move:
                    print('Zservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True

                print('>>>> Servo initialization done')

            if self.settings['to-do'] == 'move':
                print('----------- Servo moving along the scanning axis -----------')
                if self.settings['scan_axis'] in ['x', 'y', 'z']:
                    scan_instr = self._get_instr()
                    print('     ' + self.settings['scan_axis'][0] + ' Servo is moving to ' + self.settings['scan_axis'][
                        0] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][0]]) + 'mm')
                    # scan_instr.update({'position': self.settings['move_to'][self.settings['scan_axis'][0]]})
                    servo_move = scan_instr._move_servo(self.settings['move_to'][self.settings['scan_axis'][0]])
                    if not servo_move:
                        print(self.settings['scan_axis'] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True

                elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz']:
                    scan_instr_pri, scan_instr_sec = self._get_instr_2D()
                    print(self.settings['scan_axis'][1] + ' Servo is moving to ' + self.settings['scan_axis'][
                        1] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][1]]) + 'mm')
                    # scan_instr_sec.update({'position': self.settings['move_to'][self.settings['scan_axis'][1]]})
                    servo_move = scan_instr_sec._move_servo(self.settings['move_to'][self.settings['scan_axis'][1]])
                    if not servo_move:
                        print(self.settings['scan_axis'][1] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True
                    print(self.settings['scan_axis'][0] + ' Servo is moving to ' + self.settings['scan_axis'][
                        0] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][0]]) + 'mm')
                    # scan_instr_pri.update({'position': self.settings['move_to'][self.settings['scan_axis'][0]]})
                    servo_move = scan_instr_pri._move_servo(self.settings['move_to'][self.settings['scan_axis'][0]])
                    if not servo_move:
                        print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True
                print('>>>> Servo Moving done')

            elif self.settings['to-do'] == 'sweep':
                # ESR frequency initial settings (for both 1D and 2D)
                self.current_esr_cntr_freq = self.settings['exp_settings']['esr_cntr_freq']
                self.current_esr2_cntr_freq = self.settings['exp_settings']['esr2_cntr_freq']
                self.esr_cntr_freq_todo = self.current_esr_cntr_freq
                self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

                set_tracking_parameters()

                # 1D scan (forward and backward) (note that 2D scan is disabled for now)
                if self.settings['scan_axis'] in ['x', 'y', 'z']:
                    # get the relevant instrument (servo) for controlling the magnet.
                    scan_instr = self._get_instr()
                    # scan_instr._connect()
                    scan_instr.update({'velocity': self.settings['servo_initial']['moving_velocity']})
                    # get positions for the scan.
                    scan_pos = self._get_scan_positions()

                    # forward and backward sweeps
                    self.data = {'counts': deque(), 'counts_r': deque(), 'esr_fo': deque(), 'esr_fo_r': deque(),
                                 'esr_wo': deque(), 'esr_wo_r': deque(), 'esr_ctrst': deque(), 'esr_ctrst_r': deque(),
                                 'esr2_fo': deque(), 'esr2_fo_r': deque(), 'esr2_wo': deque(), 'esr2_wo_r': deque(),
                                 'esr2_ctrst': deque(), 'esr2_ctrst_r': deque()}

                    self.data['positions'] = scan_pos[0]
                    self.data['positions_r'] = scan_pos[0][::-1]
                    self.positions = {'positions': deque()}

                    # loop over scan positions and call the scripts
                    index = 0
                    # 1D Forward Sweep
                    for pos_index in range(0, len(self.data['positions'])):
                        print('len(self.data[]',len(self.data['positions']))
                        if self._abort:
                            break

                        # Set the sweeping TDC001 to be at the initial position
                        new_pos = float(self.data['positions'][pos_index])
                        print('============= Start (index = ' + str(index) + ', Forward) =================')
                        print('----------- Magnet Position: {:0.2f} mm -----------'.format(new_pos))
                        # scan_instr.update({'position': new_pos})  # actually move the instrument to that location.
                        servo_move = scan_instr._move_servo(new_pos)
                        if not servo_move:
                            print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')

                        # If this is not within the safety limits of the instruments, it will not actually move and say so in the log

                        # Do the tracking if it's time to
                        print('---------------- Tracking ----------------')
                        do_tracking(index)

                        # Do the actual measurements
                        print('---------------- Experiment ----------------')

                        ESR_Success = False
                        Rabi_Success = False

                        if self.settings['exp_to_do']['fluorescence']:
                            fluor_data = self.meas_fluorescence(index=index)
                            # add to output structures which will be plotted
                            self.data['counts'].append(np.mean(fluor_data))

                        if self.settings['exp_to_do']['esr']:
                            esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                       self.settings['exp_settings']['esr_freq_range'], label='esr1',
                                                       index=index)

                            if esr_fit_data is None:
                                print('--> No ESR fitting')
                                # add to output structures which will be plotted
                                self.data['esr_fo'].append(0.0)
                                self.data['esr_wo'].append(0.0)
                                self.data['esr_ctrst'].append(0.0)

                            elif len(esr_fit_data) == 4:
                                if esr_fit_data[3] < 0.5e6:
                                    self.data['esr_fo'].append(0.0)
                                    self.data['esr_wo'].append(0.0)
                                    self.data['esr_ctrst'].append(0.0)
                                    print(
                                        '--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print(
                                        '--> Good, find one ESR peak :). fo = ' + str(
                                            esr_fit_data[2]) + ' Hz, wo = ' + str(
                                            esr_fit_data[3]) + 'Hz')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo'].append(esr_fit_data[2])
                                    self.data['esr_wo'].append(esr_fit_data[3])
                                    self.data['esr_ctrst'].append(esr_fit_data[1])
                                    # update the ESR center frequency
                                    self.current_esr_cntr_freq = esr_fit_data[2]
                                    ESR_Success = True

                            elif len(esr_fit_data) == 6:
                                # self.data['esr_fo'].append(0.0)
                                # self.data['esr_wo'].append(0.0)
                                # self.data['esr_ctrst'].append(0.0)
                                # print('--> Find two ESRs peak, but only one is expected. No Fit is recorded.')
                                if esr_fit_data[1] < 0.5e6:
                                    self.data['esr_fo'].append(0.0)
                                    self.data['esr_wo'].append(0.0)
                                    self.data['esr_ctrst'].append(0.0)
                                    print(
                                        '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print('--> Find two ESR peaks, only record the first peak info')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo'].append(esr_fit_data[4])
                                    self.data['esr_wo'].append(esr_fit_data[1])
                                    self.data['esr_ctrst'].append(esr_fit_data[2])
                                    # update the ESR center frequency
                                    self.current_esr_cntr_freq = esr_fit_data[4]

                        if self.settings['exp_to_do']['Rabi']:

                            if ESR_Success:
                                self.flag_rabi_plot = True
                                print('==> rabi starts')
                                Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time = self.do_rabi(
                                    self.current_esr_cntr_freq, label='rabi', index=index)

                            else:
                                Rabi_Success = False
                                print('--> No ESR resonance found. Abort doing Rabi.')

                        if self.settings['exp_to_do']['PDD']:
                            if Rabi_Success:
                                self.flag_pdd_plot = True
                                print('==> pdd starts')
                                self.do_pdd(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='pdd',
                                            index=index)

                            else:
                                print('--> No Rabi information found. Abort doing PDD.')

                        if self.settings['exp_to_do']['Ramsey']:
                            if Rabi_Success:
                                self.flag_ramsey_plot = True
                                print('==> ramsey starts')
                                self.do_ramsey(mw_power, mw_freq, pi_half_time, three_pi_half_time,
                                               label='ramsey', index=index)
                            else:
                                print('--> No Rabi information found. Abort doing Ramsey.')

                        # if self.settings['exp_to_do']['esr2']:
                        #     esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                        #                                 self.settings['exp_settings']['esr2_freq_range'], label='esr2',
                        #                                 index=index)
                        #     if esr2_fit_data is None:
                        #         print('--> No ESR2 fitting')
                        #         # add to output structures which will be plotted
                        #         self.data['esr2_fo'].append(0.0)
                        #         self.data['esr2_wo'].append(0.0)
                        #         self.data['esr2_ctrst'].append(0.0)
                        #
                        #     elif len(esr2_fit_data) == 4:
                        #         if esr2_fit_data[3] < 0.5e6:
                        #             self.data['esr2_fo'].append(0.0)
                        #             self.data['esr2_wo'].append(0.0)
                        #             self.data['esr2_ctrst'].append(0.0)
                        #             print(
                        #                 '--> Find one ESR2 peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                        #         else:
                        #             print('--> Good, find one ESR2 peak :). fo = ' + str(
                        #                 esr2_fit_data[2]) + ' Hz, wo = ' + str(
                        #                 esr2_fit_data[3]) + 'Hz')
                        #             # add to output structures which will be plotted
                        #             self.data['esr2_fo'].append(esr2_fit_data[2])
                        #             self.data['esr2_wo'].append(esr2_fit_data[3])
                        #             self.data['esr2_ctrst'].append(esr2_fit_data[1])
                        #             # update the ESR2 center frequency
                        #             self.current_esr2_cntr_freq = esr2_fit_data[2]
                        #     elif len(esr2_fit_data) == 6:
                        #         # self.data['esr2_fo'].append(0.0)
                        #         # self.data['esr2_wo'].append(0.0)
                        #         # self.data['esr2_ctrst'].append(0.0)
                        #         # print(
                        #         #     '--> Find two ESR2 peak, but only one is expected. No Fit is recorded.')
                        #         if esr2_fit_data[1] < 0.5e6:
                        #             self.data['esr2_fo'].append(0.0)
                        #             self.data['esr2_wo'].append(0.0)
                        #             self.data['esr2_ctrst'].append(0.0)
                        #             print(
                        #                 '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                        #         else:
                        #             print('--> Find two ESR2 peaks, only record the second peak info')
                        #             # add to output structures which will be plotted
                        #             self.data['esr2_fo'].append(esr2_fit_data[5])
                        #             self.data['esr2_wo'].append(esr2_fit_data[1])
                        #             self.data['esr2_ctrst'].append(esr2_fit_data[3])
                        #
                        #             # update the ESR2 center frequency
                        #             self.current_esr2_cntr_freq = esr2_fit_data[5]

                        print('==================== Finished (Forward) =======================')
                        # record the position
                        self.positions['positions'].append(new_pos)
                        self.progress = index * 100. / (len(self.data['positions']) + len(self.data['positions_r']))
                        self.updateProgress.emit(int(self.progress))

                        index = index + 1
                    # the end of the for loop for the forward 1D sweep

                    if self.settings['exp_to_do']['backward_sweep']:
                        # 1D Backward Sweep
                        for pos_r_index in range(0, len(self.data['positions_r'])):
                            if self._abort:
                                break

                            # Set the sweeping TDC001 to be at the initial position for the backward sweep
                            new_pos = float(self.data['positions_r'][pos_r_index])
                            print('============ Start (index = ' + str(index) + ', Backward) =================')
                            print('----------- Magnet Position: {:0.2f} mm -----------'.format(new_pos))
                            # scan_instr.update({'position': new_pos})  # actually move the instrument to that location.
                            servo_move = scan_instr._move_servo(new_pos)
                            if not servo_move:
                                print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')
                            # If this is not within the safety limits of the instruments, it will not actually move and say so in the log

                            # Do the tracking if it's time to
                            print('---------------- Tracking ----------------')
                            do_tracking(index)

                            # Do the actual measurements
                            print('---------------- Experiment ----------------')

                            ESR_Success = False
                            Rabi_Success = False

                            if self.settings['exp_to_do']['fluorescence']:
                                fluor_data = self.meas_fluorescence(index=index)
                                # add to output structures which will be plotted
                                self.data['counts_r'].append(np.mean(fluor_data))

                            if self.settings['exp_to_do']['esr']:
                                esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                           self.settings['exp_settings']['esr_freq_range'], label='esr1',
                                                           index=index)

                                if esr_fit_data is None:
                                    print('--> No ESR fitting')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo_r'].append(0.0)
                                    self.data['esr_wo_r'].append(0.0)
                                    self.data['esr_ctrst_r'].append(0.0)

                                elif len(esr_fit_data) == 4:
                                    if esr_fit_data[3] < 0.5e6:
                                        self.data['esr_fo_r'].append(0.0)
                                        self.data['esr_wo_r'].append(0.0)
                                        self.data['esr_ctrst_r'].append(0.0)
                                        print(
                                            '--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print(
                                            '--> Good, find one ESR peak :). fo = ' + str(
                                                esr_fit_data[2]) + ' Hz, wo = ' + str(
                                                esr_fit_data[3]) + 'Hz')
                                        # add to output structures which will be plotted
                                        self.data['esr_fo_r'].append(esr_fit_data[2])
                                        self.data['esr_wo_r'].append(esr_fit_data[3])
                                        self.data['esr_ctrst_r'].append(esr_fit_data[1])
                                        # update the ESR center frequency
                                        self.current_esr_cntr_freq = esr_fit_data[2]
                                        ESR_Success = False

                                elif len(esr_fit_data) == 6:
                                    # self.data['esr_fo_r'].append(0.0)
                                    # self.data['esr_wo_r'].append(0.0)
                                    # self.data['esr_ctrst_r'].append(0.0)
                                    # print(
                                    #     '--> Find two ESR peak, but only one is expected. No Fit is recorded.')
                                    if esr_fit_data[1] < 0.5e6:
                                        self.data['esr_fo_r'].append(0.0)
                                        self.data['esr_wo_r'].append(0.0)
                                        self.data['esr_ctrst_r'].append(0.0)
                                        print(
                                            '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print('--> Find two ESR peaks, only record the first peak info')
                                        # add to output structures which will be plotted
                                        self.data['esr_fo_r'].append(esr_fit_data[4])
                                        self.data['esr_wo_r'].append(esr_fit_data[1])
                                        self.data['esr_ctrst_r'].append(esr_fit_data[2])
                                        # update the ESR center frequency
                                        self.current_esr_cntr_freq = esr_fit_data[4]

                            if self.settings['exp_to_do']['Rabi']:

                                if ESR_Success:
                                    self.flag_rabi_plot = True
                                    print('==> rabi starts')
                                    Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time = self.do_rabi(
                                        self.current_esr_cntr_freq, label='rabi', index=index)

                                else:
                                    Rabi_Success = False
                                    print('--> No ESR resonance found. Abort doing Rabi.')

                            if self.settings['exp_to_do']['PDD']:
                                if Rabi_Success:
                                    self.flag_pdd_plot = True
                                    print('==> pdd starts')
                                    self.do_pdd(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='pdd',
                                                index=index)
                                else:
                                    print('--> No Rabi information found. Abort doing PDD.')

                            if self.settings['exp_to_do']['Ramsey']:
                                if Rabi_Success:
                                    self.flag_ramsey_plot = True
                                    print('==> ramsey starts')
                                    self.do_ramsey(mw_power, mw_freq, pi_half_time, three_pi_half_time,
                                                   label='ramsey', index=index)
                                else:
                                    print('--> No Rabi information found. Abort doing Ramsey.')

                            pass


                            # if self.settings['exp_to_do']['esr2']:
                            #     esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                            #                                 self.settings['exp_settings']['esr2_freq_range'], label='esr2',
                            #                                 index=index)
                            #     if esr2_fit_data is None:
                            #         print('--> No ESR2 fitting')
                            #         # add to output structures which will be plotted
                            #         self.data['esr2_fo_r'].append(0.0)
                            #         self.data['esr2_wo_r'].append(0.0)
                            #         self.data['esr2_ctrst_r'].append(0.0)
                            #
                            #     elif len(esr2_fit_data) == 4:
                            #         if esr2_fit_data[3] < 0.5e6:
                            #             self.data['esr2_fo_r'].append(0.0)
                            #             self.data['esr2_wo_r'].append(0.0)
                            #             self.data['esr2_ctrst_r'].append(0.0)
                            #             print(
                            #                 '--> Find one ESR2 peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                            #         else:
                            #             print('--> Good, find one ESR2 peak :). fo = ' + str(
                            #                 esr2_fit_data[2]) + ' Hz, wo = ' + str(
                            #                 esr2_fit_data[3]) + 'Hz')
                            #             # add to output structures which will be plotted
                            #             self.data['esr2_fo_r'].append(esr2_fit_data[2])
                            #             self.data['esr2_wo_r'].append(esr2_fit_data[3])
                            #             self.data['esr2_ctrst_r'].append(esr2_fit_data[1])
                            #             # update the ESR2 center frequency
                            #             self.current_esr2_cntr_freq = esr2_fit_data[2]
                            #     elif len(esr2_fit_data) == 6:
                            #         # self.data['esr2_fo_r'].append(0.0)
                            #         # self.data['esr2_wo_r'].append(0.0)
                            #         # self.data['esr2_ctrst_r'].append(0.0)
                            #         # print(
                            #         #     '--> Find two ESR2 peak, but only one is expected. No Fit is recorded.')
                            #
                            #         if esr2_fit_data[1] < 0.5e6:
                            #             self.data['esr2_fo_r'].append(0.0)
                            #             self.data['esr2_wo_r'].append(0.0)
                            #             self.data['esr2_ctrst_r'].append(0.0)
                            #             print(
                            #                 '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                            #         else:
                            #             print('--> Find two ESR2 peaks, only record the first peak info')
                            #             # add to output structures which will be plotted
                            #             self.data['esr2_fo_r'].append(esr2_fit_data[5])
                            #             self.data['esr2_wo_r'].append(esr2_fit_data[1])
                            #             self.data['esr2_ctrst_r'].append(esr2_fit_data[3])
                            #             # update the ESR2 center frequency
                            #             self.current_esr2_cntr_freq = esr2_fit_data[5]

                            print('=================== Finished (Backward) =======================')
                            # record the position
                            self.positions['positions'].append(new_pos)
                            self.progress = index * 100. / (len(self.data['positions']) + len(self.data['positions_r']))
                            self.updateProgress.emit(int(self.progress))

                            index = index + 1

                            pass
                        # the end of the for loop for the backward 1D sweep

                    # clean up data, as in daq_read_counter
                    # convert deque object to numpy array or list
                    if 'counts' in self.data.keys() is not None:
                        # self.data['counts'] = list(self.data['counts'])
                        self.data['counts'] = np.asarray(self.data['counts'])
                    if 'esr_fo' in self.data.keys() is not None:
                        # self.data['esr_fo'] = list(self.data['esr_fo'])
                        self.data['esr_fo'] = np.asarray(self.data['esr_fo'])
                    if 'esr_wo' in self.data.keys() is not None:
                        # self.data['esr_wo'] = list(self.data['esr_wo'])
                        self.data['esr_wo'] = np.asarray(self.data['esr_wo'])
                    if 'esr_ctrst' in self.data.keys() is not None:
                        self.data['esr_ctrst'] = np.asarray(self.data['esr_ctrst'])
                    if 'esr2_fo' in self.data.keys() is not None:
                        # self.data['esr2_fo'] = list(self.data['esr2_fo'])
                        self.data['esr2_fo'] = np.asarray(self.data['esr2_fo'])
                    if 'esr2_wo' in self.data.keys() is not None:
                        # self.data['esr2_wo'] = list(self.data['esr2_wo'])
                        self.data['esr2_wo'] = np.asarray(self.data['esr2_wo'])
                    if 'esr2_ctrst' in self.data.keys() is not None:
                        self.data['esr2_ctrst'] = np.asarray(self.data['esr2_ctrst'])
                    if 'counts_r' in self.data.keys() is not None:
                        # self.data['counts'] = list(self.data['counts'])
                        self.data['counts_r'] = np.asarray(self.data['counts_r'])
                    if 'esr_fo_r' in self.data.keys() is not None:
                        # self.data['esr_fo'] = list(self.data['esr_fo'])
                        self.data['esr_fo_r'] = np.asarray(self.data['esr_fo_r'])
                    if 'esr_wo_r' in self.data.keys() is not None:
                        # self.data['esr_wo'] = list(self.data['esr_wo'])
                        self.data['esr_wo_r'] = np.asarray(self.data['esr_wo_r'])
                    if 'esr_ctrst_r' in self.data.keys() is not None:
                        self.data['esr_ctrst_r'] = np.asarray(self.data['esr_ctrst_r'])
                    if 'esr2_fo_r' in self.data.keys() is not None:
                        # self.data['esr2_fo'] = list(self.data['esr2_fo'])
                        self.data['esr2_fo_r'] = np.asarray(self.data['esr2_fo_r'])
                    if 'esr2_wo_r' in self.data.keys() is not None:
                        # self.data['esr2_wo'] = list(self.data['esr2_wo'])
                        self.data['esr2_wo_r'] = np.asarray(self.data['esr2_wo_r'])
                    if 'esr2_ctrst_r' in self.data.keys() is not None:
                        self.data['esr2_ctrst_r'] = np.asarray(self.data['esr2_ctrst_r'])
                # 2D scan (forward and backward) (disabled for now...)
                # elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz']:
                #
                #     # get the relevant instrument for controlling the magnet.
                #     scan_instr_pri, scan_instr_sec = self._get_instr_2D()
                #     scan_instr_pri.update({'velocity': self.settings['servo_initial']['moving_velocity']})
                #     scan_instr_sec.update({'velocity': self.settings['servo_initial']['moving_velocity']})
                #
                #     # get the positions for the scan.
                #     scan_pos_pri, scan_pos_sec = self._get_scan_positions_2D()
                #     scan_pos_pri_r = scan_pos_pri[::-1]
                #
                #     # [self.xVmin, self.xVmax, self.yVmin, self.yVmax, self.zVmin, self.zVmax] = self.pts_to_extent(
                #     #     self.settings['sweep_center'], self.settings['sweep_span'])
                #
                #     # Data Structure
                #     # self.data = {'bounds': [scan_pos_pri[0], scan_pos_pri[-1], scan_pos_sec[0], scan_pos_sec[-1],],
                #     self.data = {'bounds': [scan_pos_pri[0], scan_pos_pri[-1], scan_pos_sec[-1], scan_pos_sec[0], ],
                #                  'scan_pos_pri': scan_pos_pri, 'scan_pos_sec': scan_pos_sec,
                #                  'counts': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'counts_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_fo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_fo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_wo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_wo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_ctrst': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_ctrst_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_fo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_fo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_wo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_wo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_ctrst': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_ctrst_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri))))}
                #
                #     print('bounds:', self.data['bounds'])
                #
                #     # 2D forward and backward sweeps
                #     index = 0
                #     for pos_sec_index in range(0, len(scan_pos_sec)):
                #         if self._abort:
                #             break
                #
                #         # Set the sweeping TDC001 to be at the initial position
                #         new_pos_sec = float(scan_pos_sec[pos_sec_index])
                #         print('★★★★★★★★★★★★★  Start (index = ' + str(index) + ', Secondary) ★★★★★★★★★★★★★★')
                #         print('------ Moving to Secondary Position: ' + self.settings['scan_axis'][
                #             1] + ' = {:0.2f} mm --------'.format(new_pos_sec))
                #         # scan_instr_sec.update({'position': new_pos_sec})  # actually move the instrument to that location.
                #         servo_move = scan_instr_sec._move_servo(new_pos_sec)
                #         if not servo_move:
                #             print(self.settings['scan_axis'][1] + 'servo fails to move. Experiment stopped.')
                #         # If this is not within the safety limits of the instruments, it will not actually move and say so in the log
                #
                #         # Forward Primary loop
                #         for pos_pri_index in range(0, len(scan_pos_pri)):
                #             if self._abort:
                #                 break
                #             new_pos_pri = float(scan_pos_pri[pos_pri_index])
                #             print('============= Start (index = ' + str(index) + ', Primary, Forward) ============')
                #             print('------ Moving to Primary Position: ' + self.settings['scan_axis'][
                #                 0] + ' = {:0.2f} mm --------'.format(new_pos_pri))
                #             # scan_instr_pri.update({'position': new_pos_pri})  # actually move the instrument to that location.
                #             servo_move = scan_instr_pri._move_servo(new_pos_pri)
                #             if not servo_move:
                #                 print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')
                #
                #             print('---------------- Tracking ----------------')
                #             do_tracking(index)
                #
                #             # Do the actual measurements
                #             print('---------------- Experiment ----------------')
                #             if self.settings['exp_to_do']['fluorescence']:
                #                 fluor_data = self.meas_fluorescence(index=index)
                #                 # add to output structures which will be plotted
                #                 # self.data['counts'].append(np.mean(fluor_data))
                #                 self.data['counts'][pos_sec_index][pos_pri_index] = np.mean(fluor_data)
                #             if self.settings['exp_to_do']['esr']:
                #                 esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                #                                            self.settings['exp_settings']['esr_freq_range'],
                #                                            label='esr1', index=index)
                #
                #                 if esr_fit_data is None:
                #                     print('--> No ESR fitting :(')
                #                     # self.data['esr_fo'].append(0.0)
                #                     # self.data['esr_wo'].append(0.0)
                #
                #                 elif len(esr_fit_data) == 4:
                #                     if esr_fit_data[3] < 0.5e6:
                #                         # self.data['esr_fo'].append(0.0)
                #                         # self.data['esr_wo'].append(0.0)
                #                         print(
                #                             '--> Find one ESR peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print(
                #                             '--> Good, find one ESR peak :). fo = ' + str(
                #                                 esr_fit_data[2]) + ' Hz, wo = ' + str(
                #                                 esr_fit_data[3]) + 'Hz')
                #                         # add to output structures which will be plotted
                #                         # self.data['esr_fo'].append(esr_fit_data[2])
                #                         # self.data['esr_wo'].append(esr_fit_data[3])
                #                         self.data['esr_fo'][pos_sec_index][pos_pri_index] = esr_fit_data[2]
                #                         self.data['esr_wo'][pos_sec_index][pos_pri_index] = esr_fit_data[3]
                #                         self.data['esr_ctrst'][pos_sec_index][pos_pri_index] = esr_fit_data[1]
                #
                #                         # update the ESR center frequency
                #                         self.current_esr_cntr_freq = esr_fit_data[2]
                #
                #                 elif len(esr_fit_data) == 6:
                #                     # print(
                #                     #     '--> Find two ESR peaks, but only one is expected. No Fit is recorded.')
                #                     if esr_fit_data[1] < 0.5e6:
                #
                #                         print(
                #                             '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Find two ESR peaks, only record the first peak info')
                #                         # add to output structures which will be plotted
                #
                #                         self.data['esr_fo'][pos_sec_index][pos_pri_index] = esr_fit_data[4]
                #                         self.data['esr_wo'][pos_sec_index][pos_pri_index] = esr_fit_data[1]
                #                         self.data['esr_ctrst'][pos_sec_index][pos_pri_index] = esr_fit_data[2]
                #                         # update the ESR center frequency
                #                         self.current_esr_cntr_freq = esr_fit_data[4]
                #             if self.settings['exp_to_do']['esr2']:
                #                 esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                #                                             self.settings['exp_settings']['esr2_freq_range'],
                #                                             label='esr2', index=index)
                #                 if esr2_fit_data is None:
                #                     print('--> No ESR2 fitting :(')
                #                     # self.data['esr2_fo'].append(0.0)
                #                     # self.data['esr2_wo'].append(0.0)
                #                 elif len(esr2_fit_data) == 4:
                #                     if esr2_fit_data[3] < 0.5e6:
                #                         print(
                #                             '--> Find one ESR2 peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Good, find one ESR2 peak :). fo = ' + str(
                #                             esr2_fit_data[2]) + ' Hz, wo = ' + str(
                #                             esr2_fit_data[3]) + 'Hz')
                #                         # add to output structures which will be plotted
                #
                #                         self.data['esr2_fo'][pos_sec_index][pos_pri_index] = esr2_fit_data[2]
                #                         self.data['esr2_wo'][pos_sec_index][pos_pri_index] = esr2_fit_data[3]
                #                         self.data['esr2_ctrst'][pos_sec_index][pos_pri_index] = esr2_fit_data[1]
                #                         # update the ESR2 center frequency
                #                         self.current_esr2_cntr_freq = esr2_fit_data[2]
                #                 elif len(esr2_fit_data) == 6:
                #                     # print(
                #                     #     '--> Find two ESR2 peaks, but only one is expected. No Fit is recorded.')
                #                     if esr2_fit_data[1] < 0.5e6:
                #
                #                         print(
                #                             '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Find two ESR2 peaks, only record the first peak info')
                #                         # add to output structures which will be plotted
                #
                #                         self.data['esr2_fo'][pos_sec_index][pos_pri_index] = esr2_fit_data[5]
                #                         self.data['esr2_wo'][pos_sec_index][pos_pri_index] = esr2_fit_data[1]
                #                         self.data['esr2_ctrst'][pos_sec_index][pos_pri_index] = esr2_fit_data[3]
                #                         # update the ESR2 center frequency
                #                         self.current_esr2_cntr_freq = esr2_fit_data[5]
                #
                #             print('==================== Finished (Forward) =======================')
                #             self.progress = index * 100. / (len(scan_pos_pri) * len(scan_pos_sec) * 2)
                #             self.updateProgress.emit(int(self.progress))
                #             index = index + 1
                #         # the end of the forward primary loop
                #         pass
                #
                #         # Backward Primary loop
                #         for pos_pri_r_index in range(0, len(scan_pos_pri_r)):
                #             if self._abort:
                #                 break
                #             new_pos_pri_r = float(scan_pos_pri_r[pos_pri_r_index])
                #             print('============= Start (index = ' + str(index) + ', Primary, Backward) ============')
                #             print('------ Moving to Primary Position: ' + self.settings['scan_axis'][
                #                 0] + ' = {:0.2f} mm --------'.format(new_pos_pri_r))
                #             # scan_instr_pri.update({'position': new_pos_pri_r})  # actually move the instrument to that location.
                #             servo_move = scan_instr_pri._move_servo(new_pos_pri_r)
                #             if not servo_move:
                #                 print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')
                #
                #             print('---------------- Tracking ----------------')
                #             do_tracking(index)
                #
                #             # Do the actual measurements
                #             print('---------------- Experiment ----------------')
                #             if self.settings['exp_to_do']['fluorescence']:
                #                 fluor_data = self.meas_fluorescence(index=index)
                #                 # add to output structures which will be plotted
                #                 # self.data['counts'].append(np.mean(fluor_data))
                #                 self.data['counts_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = np.mean(fluor_data)
                #             if self.settings['exp_to_do']['esr']:
                #                 esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                #                                            self.settings['exp_settings']['esr_freq_range'],
                #                                            label='esr1', index=index)
                #
                #                 if esr_fit_data is None:
                #                     print('--> No ESR fitting :(')
                #                     # self.data['esr_fo'].append(0.0)
                #                     # self.data['esr_wo'].append(0.0)
                #
                #                 elif len(esr_fit_data) == 4:
                #                     if esr_fit_data[3] < 0.5e6:
                #                         # self.data['esr_fo'].append(0.0)
                #                         # self.data['esr_wo'].append(0.0)
                #                         print(
                #                             '--> Find one ESR peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print(
                #                             '--> Good, find one ESR peak :). fo = ' + str(
                #                                 esr_fit_data[2]) + ' Hz, wo = ' + str(
                #                                 esr_fit_data[3]) + 'Hz')
                #                         # add to output structures which will be plotted
                #                         # self.data['esr_fo'].append(esr_fit_data[2])
                #                         # self.data['esr_wo'].append(esr_fit_data[3])
                #                         self.data['esr_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[2]
                #                         self.data['esr_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[3]
                #                         self.data['esr_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[1]
                #
                #                         # update the ESR center frequency
                #                         self.current_esr_cntr_freq = esr_fit_data[2]
                #
                #                 elif len(esr_fit_data) == 6:
                #                     # print(
                #                     #     '--> Find two ESR peaks, but only one is expected. No Fit is recorded.')
                #                     if esr_fit_data[1] < 0.5e6:
                #
                #                         print(
                #                             '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Find two ESR peaks, only record the first peak info')
                #                         # add to output structures which will be plotted
                #
                #                         self.data['esr_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[4]
                #                         self.data['esr_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[1]
                #                         self.data['esr_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[2]
                #                         # update the ESR center frequency
                #                         self.current_esr_cntr_freq = esr_fit_data[4]
                #             if self.settings['exp_to_do']['esr2']:
                #                 esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                #                                             self.settings['exp_settings']['esr2_freq_range'],
                #                                             label='esr2', index=index)
                #
                #                 if esr2_fit_data is None:
                #                     print('--> No ESR2 fitting :(')
                #                     # self.data['esr2_fo'].append(0.0)
                #                     # self.data['esr2_wo'].append(0.0)
                #                 elif len(esr2_fit_data) == 4:
                #                     if esr2_fit_data[3] < 0.5e6:
                #                         # self.data['esr2_fo'].append(0.0)
                #                         # self.data['esr2_wo'].append(0.0)
                #                         print(
                #                             '--> Find one ESR2 peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Good, find one ESR2 peak :). fo = ' + str(
                #                             esr2_fit_data[2]) + ' Hz, wo = ' + str(
                #                             esr2_fit_data[3]) + 'Hz')
                #                         # add to output structures which will be plotted
                #                         # self.data['esr2_fo'].append(esr2_fit_data[2])
                #                         # self.data['esr2_wo'].append(esr2_fit_data[3])
                #                         self.data['esr2_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             2]
                #                         self.data['esr2_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             3]
                #                         self.data['esr2_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             1]
                #                         # update the ESR2 center frequency
                #                         self.current_esr2_cntr_freq = esr2_fit_data[2]
                #                 elif len(esr2_fit_data) == 6:
                #                     # print(
                #                     #     '--> Find two ESR2 peaks, but only one is expected. No Fit is recorded.')
                #                     if esr2_fit_data[1] < 0.5e6:
                #                         # self.data['esr2_fo'].append(0.0)
                #                         # self.data['esr2_wo'].append(0.0)
                #                         print(
                #                             '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Find two ESR2 peaks, only record the first peak info')
                #                         # add to output structures which will be plotted
                #                         # self.data['esr2_fo'].append(esr2_fit_data[4])
                #                         # self.data['esr2_wo'].append(esr2_fit_data[1])
                #                         self.data['esr2_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             5]
                #                         self.data['esr2_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             1]
                #                         self.data['esr2_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             3]
                #                         # update the ESR2 center frequency
                #                         self.current_esr2_cntr_freq = esr2_fit_data[5]
                #
                #             print('==================== Finished (Backward) =======================')
                #             self.progress = index * 100. / (len(scan_pos_pri) * len(scan_pos_sec) * 2)
                #             self.updateProgress.emit(int(self.progress))
                #             index = index + 1
                #         # the end of the backward primary loop
                #         pass
                #
                #         print('★★★★★★★★★★★★★★★★★★  Finished (Secondary) ★★★★★★★★★★★★★★★★★★')
                #
                #     # the end of the 2D sweep
                #     pass

    def _plot(self, axes_list, data=None):
        # COMMENT_ME

        if data is None:
            data = self.data
        if self.settings['scan_axis'] in ['x', 'y', 'z'] and self.settings['to-do'] == 'sweep':
            print('(1D plot)')
            if self.data['counts'] is not None:
                lbls1 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]',
                         'counts [kcps]', 'Fluorescence']
                plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['positions'], np.array(self.data['counts']),
                                          lbls1, x_r=self.data['positions_r'], y1_r=np.array(self.data['counts_r']))

            if self.settings['exp_settings']['to_plot'] ==  'contrast': # to plot contrast
                if self.data['esr_fo'] is not None and self.data['esr_ctrst'] is not None:
                    lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                             'contrast', 'ESR']
                    plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                            np.array(self.data['esr_fo']),
                                            np.array(self.data['esr_ctrst']), lbls2, x_r=self.data['positions_r'],
                                            y1_r=np.array(self.data['esr_fo_r']), y2_r=np.array(self.data['esr_ctrst_r']))
                # if self.data['esr2_fo'] is not None and self.data['esr2_ctrst'] is not None:
                #     lbls3 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                #              'contrast', 'ESR 2']
                #     plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'],
                #                             np.array(self.data['esr2_fo']),
                #                             np.array(self.data['esr2_ctrst']), lbls3, x_r=self.data['positions_r'],
                #                             y1_r=np.array(self.data['esr2_fo_r']), y2_r=np.array(self.data['esr2_ctrst_r']))
            else:
                if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                    lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                             'wo[Hz]', 'ESR']
                    plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                            np.array(self.data['esr_fo']),
                                            np.array(self.data['esr_wo']), lbls2, x_r=self.data['positions_r'],
                                            y1_r=np.array(self.data['esr_fo_r']), y2_r=np.array(self.data['esr_wo_r']))
                # if self.data['esr2_fo'] is not None and self.data['esr2_wo'] is not None:
                #     lbls3 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                #              'wo[Hz]', 'ESR 2']
                #     plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'],
                #                             np.array(self.data['esr2_fo']),
                #                             np.array(self.data['esr2_wo']), lbls3, x_r=self.data['positions_r'],
                #                             y1_r=np.array(self.data['esr2_fo_r']), y2_r=np.array(self.data['esr2_wo_r']))

        # elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz'] and self.settings['to-do'] == 'sweep':
        #     print('(2D plot)')
        #     if self.data['counts'] is not None:
        #         plot_magnet_sweep2D_Fluor(data['counts'], data['bounds'], axes_list[0], axes_labels=self.settings['scan_axis'], title = 'Fluor Forward', colorbar_name = 'kcps')
        #     if self.data['counts_r'] is not None:
        #         plot_magnet_sweep2D_Fluor(data['counts_r'], data['bounds'], axes_list[2], axes_labels=self.settings['scan_axis'], title = 'Fluor Backward', colorbar_name = 'kcps')
        #     if self.data['esr_fo'] is not None:
        #         plot_magnet_sweep2D_Fluor(data['esr_fo']/1e6, data['bounds'], axes_list[3], axes_labels=self.settings['scan_axis'], title = 'ESR Forward', colorbar_name = 'MHz')
        #     if self.data['esr_fo_r'] is not None:
        #         plot_magnet_sweep2D_Fluor(data['esr_fo_r']/1e6, data['bounds'], axes_list[4], axes_labels=self.settings['scan_axis'], title = 'ESR Backward', colorbar_name = 'MHz')
        #     # elif self.data['esr_wo'] is not None:
        #     #     plot_magnet_sweep2D_Fluor(data['esr_wo']/1e6, data['bounds'], axes_list[4], axes_labels=self.settings['scan_axis'], title = 'ESR width Forward', colorbar_name = 'MHz')
        #     if self.data['esr2_fo'] is not None:
        #         plot_magnet_sweep2D_Fluor(data['esr2_fo']/1e6, data['bounds'], axes_list[5], axes_labels=self.settings['scan_axis'], title = 'ESR2 Forward', colorbar_name = 'MHz')
        #     if self.data['esr2_fo_r'] is not None:
        #         plot_magnet_sweep2D_Fluor(data['esr2_fo_r']/1e6, data['bounds'], axes_list[6], axes_labels=self.settings['scan_axis'], title = 'ESR2 Backward', colorbar_name = 'MHz')
        #     # elif self.data['esr2_wo'] is not None:
        #     #     plot_magnet_sweep2D_Fluor(data['esr2_wo']/1e6, data['bounds'], axes_list[6], axes_labels=self.settings['scan_axis'], title = 'ESR2 width Forward', colorbar_name = 'MHz')

    def _update_plot(self, axes_list):

        # print('_update_plot')

        if self._current_subscript_stage['current_subscript'] is self.scripts['daq_read_counter'] and self.scripts['daq_read_counter'].is_running:
            self.scripts['daq_read_counter']._plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['esr'] and self.scripts['esr'].is_running:
            # print('updating esr plot now')
            self.scripts['esr']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['find_nv'] and self.scripts['find_nv'].is_running:
            if self.flag_find_nv_plot:
                # print('self.flag_find_nv_plot is', self.flag_find_nv_plot)
                self.scripts['find_nv']._plot([axes_list[1]], colorbar=0) # this is to remove colorbar
                self.flag_find_nv_plot = False
            else:
                self.scripts['find_nv']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['optimize_z'] and self.scripts['optimize_z'].is_running:
            # print('optimize_z is running, update plot')
            if self.flag_optimize_z_plot:
                self.scripts['optimize_z']._plot([axes_list[1]])
                self.flag_optimize_z_plot = False
            else:
                self.scripts['optimize_z']._update_plot ([axes_list[1]])

        elif self._current_subscript_stage['current_subscript'] is self.scripts['rabi'] and self.scripts['rabi'].is_running:
            # print('rabi is running, update plot')
            if self.flag_rabi_plot:
                self.scripts['rabi']._plot(axes_list)
                self.flag_rabi_plot = False
            else:
                self.scripts['rabi']._update_plot (axes_list)

        elif self._current_subscript_stage['current_subscript'] is self.scripts['pdd'] and self.scripts['pdd'].is_running:
            # print('pdd is running, update plot')
            if self.flag_pdd_plot:
                self.scripts['pdd']._plot(axes_list)
                self.flag_pdd_plot = False
            else:
                self.scripts['pdd']._update_plot (axes_list)

        elif self._current_subscript_stage['current_subscript'] is self.scripts['ramsey'] and self.scripts['ramsey'].is_running:
            # print('ramsey is running, update plot')
            if self.flag_ramsey_plot:
                self.scripts['ramsey']._plot(axes_list)
                self.flag_ramsey_plot = False
            else:
                self.scripts['ramsey']._update_plot (axes_list)


        elif self._current_subscript_stage['current_subscript'] is self.scripts['autofocus'] and self.scripts['autofocus'].is_running:
            # print('autofocus is running, update plot')
            if self.flag_autofocus_plot:
                # print('self.flag_autofocus_plot is', self.flag_autofocus_plot)
                self.scripts['autofocus']._plot([axes_list[0], axes_list[1]], colorbar=0)
                self.flag_autofocus_plot = False
                self.flag_image0_update_plot = False
            else:
                self.scripts['autofocus']._update_plot([axes_list[0], axes_list[1]])
                self.flag_image0_update_plot = False
        else:
            if self.settings['scan_axis'] in ['x', 'y', 'z'] and self.settings['to-do'] == 'sweep':
                print('(updating 1D plot)')

                if self.data['counts'] is not None:
                    lbls1 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]',
                             'counts [kcps]', 'Fluorescence']
                    plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['positions'], np.array(self.data['counts']),
                                              lbls1, x_r=self.data['positions_r'], y1_r=np.array(self.data['counts_r']))
                if self.settings['exp_settings']['to_plot'] == 'contrast':  # to plot contrast
                    if self.data['esr_fo'] is not None and self.data['esr_ctrst'] is not None:
                        lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                                 'contrast', 'ESR']
                        plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                                np.array(self.data['esr_fo']),
                                                np.array(self.data['esr_ctrst']), lbls2, x_r=self.data['positions_r'],
                                                y1_r=np.array(self.data['esr_fo_r']),
                                                y2_r=np.array(self.data['esr_ctrst_r']))
                    # if self.data['esr2_fo'] is not None and self.data['esr2_ctrst'] is not None:
                    #     lbls3 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                    #              'contrast', 'ESR 2']
                    #     plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'],
                    #                             np.array(self.data['esr2_fo']),
                    #                             np.array(self.data['esr2_ctrst']), lbls3, x_r=self.data['positions_r'],
                    #                             y1_r=np.array(self.data['esr2_fo_r']),
                    #                             y2_r=np.array(self.data['esr2_ctrst_r']))
                else: # to plot width
                    if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                        lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                                 'wo[Hz]', 'ESR']
                        plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                                np.array(self.data['esr_fo']),
                                                np.array(self.data['esr_wo']), lbls2, x_r=self.data['positions_r'],
                                                y1_r=np.array(self.data['esr_fo_r']),
                                                y2_r=np.array(self.data['esr_wo_r']))
                    # if self.data['esr2_fo'] is not None and self.data['esr2_wo'] is not None:
                    #     lbls3 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                    #              'wo[Hz]', 'ESR 2']
                    #     plot_magnet_sweep1D_ESR([axes_list[4], axes_list[5]], self.data['positions'],
                    #                             np.array(self.data['esr2_fo']),
                    #                             np.array(self.data['esr2_wo']), lbls3, x_r=self.data['positions_r'],
                    #                             y1_r=np.array(self.data['esr2_fo_r']),
                    #                             y2_r=np.array(self.data['esr2_wo_r']))

            # elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz'] and self.settings['to-do'] == 'sweep':
            #     print('(updating 2D plot)')
            #     if self.data['counts'] is not None:
            #         if self.flag_image0_update_plot:
            #             update_magnet_sweep2D_Fluor(self.data['counts'], axes_list[0])
            #         else:
            #             plot_magnet_sweep2D_Fluor(self.data['counts'], self.data['bounds'], axes_list[0],
            #                                       axes_labels=self.settings['scan_axis'], title='Fluor Forward',
            #                                       colorbar_name='kcps')
            #             self.flag_image0_update_plot = True
            #     if self.data['counts_r'] is not None:
            #         update_magnet_sweep2D_Fluor(self.data['counts_r'],axes_list[2])
            #     if self.data['esr_fo'] is not None:
            #         update_magnet_sweep2D_Fluor(self.data['esr_fo']/1e6, axes_list[3])
            #     if self.data['esr_fo_r'] is not None:
            #         update_magnet_sweep2D_Fluor(self.data['esr_fo_r']/1e6, axes_list[4])
            #     if self.data['esr2_fo'] is not None:
            #         update_magnet_sweep2D_Fluor(self.data['esr2_fo']/1e6, axes_list[5])
            #     if self.data['esr2_fo_r'] is not None:
            #         update_magnet_sweep2D_Fluor(self.data['esr2_fo_r']/1e6, axes_list[6])

    def get_axes_layout(self, figure_list):
        """
        returns the axes objects the script needs to plot its data
        this overwrites the default get_axis_layout in PyLabControl.src.core.scripts
        Args:
            figure_list: a list of figure objects
        Returns:
            axes_list: a list of axes objects

        """
        axes_list = []
        if self.settings['scan_axis'] in ['x', 'y', 'z']:
            if self._plot_refresh is True:
                for fig in figure_list:
                    fig.clf()
                # # 5 subplots in total
                # axes_list.append(figure_list[0].add_subplot(131))  # axes_list[0]
                # axes_list.append(figure_list[1].add_subplot(111))  # axes_list[1]
                # axes_list.append(figure_list[0].add_subplot(232))  # axes_list[2]
                # axes_list.append(figure_list[0].add_subplot(235))  # axes_list[3]
                # axes_list.append(figure_list[0].add_subplot(233))  # axes_list[4]
                # axes_list.append(figure_list[0].add_subplot(236))  # axes_list[5]

                # 3 subplots in total (since ESR2 is not going to be done)
                axes_list.append(figure_list[0].add_subplot(211))  # axes_list[0]
                axes_list.append(figure_list[1].add_subplot(111))  # axes_list[1]
                axes_list.append(figure_list[0].add_subplot(223))  # axes_list[2]
                axes_list.append(figure_list[0].add_subplot(224))  # axes_list[3]
                # axes_list.append(figure_list[0].add_subplot(233))  # axes_list[4]
                # axes_list.append(figure_list[0].add_subplot(236))  # axes_list[5]

            else:
                axes_list.append(figure_list[0].axes[0])
                axes_list.append(figure_list[1].axes[0])
                axes_list.append(figure_list[0].axes[1])
                axes_list.append(figure_list[0].axes[2])
                # axes_list.append(figure_list[0].axes[3])
                # axes_list.append(figure_list[0].axes[4])

            return axes_list

        # elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz']:
        #     if self._plot_refresh is True:
        #         for fig in figure_list:
        #             fig.clf()
        #         # 6 subplots in total
        #         axes_list.append(figure_list[0].add_subplot(231))  # axes_list[0]
        #         axes_list.append(figure_list[1].add_subplot(111))  # axes_list[1]
        #         axes_list.append(figure_list[0].add_subplot(234))  # axes_list[2]
        #         axes_list.append(figure_list[0].add_subplot(232))  # axes_list[3]
        #         axes_list.append(figure_list[0].add_subplot(235))  # axes_list[4]
        #         axes_list.append(figure_list[0].add_subplot(233))  # axes_list[5]
        #         axes_list.append(figure_list[0].add_subplot(236))  # axes_list[6]
        #
        #     else:
        #         axes_list.append(figure_list[0].axes[0])
        #         axes_list.append(figure_list[1].axes[0])
        #         axes_list.append(figure_list[0].axes[1])
        #         axes_list.append(figure_list[0].axes[2])
        #         axes_list.append(figure_list[0].axes[3])
        #         axes_list.append(figure_list[0].axes[4])
        #         axes_list.append(figure_list[0].axes[5])
        #
        #     return axes_list

class MagnetCoilSweep(Script):
    """
        MagnetSweep1D sweeps the position of the automatic translation stages, in 1D or 2D scans, and does the following experiments:
        (1) NV fluorescence
        (2) ESR
        (3) Rabi (optional)
        (4) Periodic Dynamical Decoupling - PDD (optional)
        (5) Ramsey (optional)
        For the optional scripts, set the right parameters in the subscripts.
        Note that only 1D scan is allowed, and only 1 ESR can be done.
        --> Last edited by ZQ 9/17/2019
    """

    _DEFAULT_SETTINGS = [
        Parameter('to-do', 'read', ['initialize', 'move', 'sweep', 'read','sweepV'],
                  'Choose to move to a point, do a magnet sweep, just read the magnet positions or sweep the voltage on the coil'),
        Parameter('servo_initial',
                  [Parameter('initialize', True, bool,
                             'whether or not to intialize the servo position before sweeping? (highly recommended)'),
                   Parameter('Xservo', 9.0, float, 'initial position of Xservo'),
                   Parameter('Yservo', 4.0, float, 'initial position of Yservo'),
                   Parameter('Zservo', 5.0, float, 'initial position of Zservo'),
                   Parameter('moving_velocity', 0.5, float, 'servo moving velocity (mm/s)'),
                   Parameter('Xservo_min', 0.0, float, 'minimum allowed position of Xservo'),
                   Parameter('Xservo_max', 23.0, float, 'maximum allowed position of Xservo'),
                   Parameter('Yservo_min', 0.0, float, 'minimum allowed position of Yservo'),
                   Parameter('Yservo_max', 13.0, float, 'maximum allowed position of Yservo'),
                   Parameter('Zservo_min', 3.0, float, 'minimum allowed position of Zservo'),
                   Parameter('Zservo_max', 25.0, float, 'maximum allowed position of Zservo'),
                   ]),

        # Parameter('scan_axis', 'xy', ['xy', 'yx', 'xz', 'zx', 'yz', 'zy', 'x', 'y', 'z'],
        #           'Choose 2D or 1D magnet sweep to perform'),
        Parameter('scan_axis', 'x', ['x', 'y', 'z'],
                  'Choose which axis to perform 1D magnet sweep'),
        Parameter('move_to',
                  [Parameter('x', 15.0, float, 'move to x-coordinate [mm]'),
                   Parameter('y', 10.0, float, 'move to y-coordinate [mm]'),
                   Parameter('z', 10.0, float, 'move to z-coordinate [mm]')
                   ]),
        Parameter('sweep_center',
                  [Parameter('x', 15.0, float, 'x-coordinate [mm] of the sweep center'),
                   Parameter('y', 10.0, float, 'y-coordinate [mm] of the sweep center'),
                   Parameter('z', 5.0, float, 'z-coordinate [mm] of the sweep center')
                   ]),
        Parameter('sweep_span',
                  [Parameter('x', 3.0, float, 'x-coordinate [mm]'),
                   Parameter('y', 0.0, float, 'y-coordinate [mm]'),
                   Parameter('z', 0.0, float, 'z-coordinate [mm]')
                   ]),
        Parameter('num_points',
                  [Parameter('x', 15, int, 'number of x points to scan'),
                   Parameter('y', 0, int, 'number of y points to scan'),
                   Parameter('z', 0, int, 'number of z points to scan')
                   ]),
        Parameter('voltages',[Parameter('min_vol', 0.0, float, 'Minimum votlage [V] in the sweep'),
                              Parameter('max_vol', 1.0, float, 'Maximum votlage [V] in the sweep'),
                              Parameter('vol_step', 0.1, float, 'Voltage step [V] in the sweep'),
                              ]),
        Parameter('exp_to_do', [Parameter('backward_sweep', False, bool, 'whether to do a backward sweep'),
                                Parameter('fluorescence', True, bool, 'measure the NV fluorescence'),
                                Parameter('esr', True, bool, 'measure the ESR of NV'),
                                # Parameter('esr2', False, bool,
                                #           'measure the ESR of NV at two different frequencies'), # disabled for this script
                                Parameter('Rabi', True, bool, 'measure Rabi at the ESR resonance frequency'),
                                Parameter('PDD', True, bool, 'measure T2 coherence times using dynamical decoupling'),
                                Parameter('Ramsey', False, bool, 'measure Ramsey')]),
        Parameter('exp_settings', [
            Parameter('intensity_wheel_esr', 298, float, 'microwave power for ESR scan'),
            Parameter('intensity_wheel_pulse', 260, float, 'minimum number of esr averages'),
            Parameter('fluorescence_time_per_pt', 0.4, float, 'time for fluorescence measurement at each point (s)'),
            Parameter('esr_mw_pwr', -10, float, 'microwave power for ESR scan'),
            Parameter('esr_avg_min', 12, int, 'minimum number of esr averages'),
            Parameter('esr_avg_max', 50, int, 'maximum number of esr averages'),
            Parameter('esr_cntr_freq', 2.82e9, float, 'center frequency for ESR scan'),
            Parameter('esr_freq_range', 8.5e7, float, 'frequency range for ESR scan (suggest 6e7 - 9e7)'),
            Parameter('esr2_cntr_freq', 2.99e9, float, 'center frequency for the second ESR scan'),
            Parameter('esr2_freq_range', 8.5e7, float, 'frequency range for the second ESR scan(suggest 6e7 - 9e7)'),
            Parameter('esr_ini_stab_time', 1, int, 'laser power stabilization time (sec)'),
            Parameter('esr_num_of_pts', 150, int, 'number of frequency points for ESR scan'),
            Parameter('esr_time_per_pt', 0.02, [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1],
                      'integration time for each point in the fast ESR scan (suggest 0.02-0.04)'),
            Parameter('esrfit_num_of_peaks', 1, [-1, 1, 2],
                      'specify number of peaks for fitting. if not specifying the number of peaks, choose -1'),
            Parameter('esrfit_minimum_counts', 0.9, float,
                      'minumum counts for an ESR to not be considered noise (suggest 0.8 - 1.01 if esr is normalized)'),
            Parameter('esrfit_contrast_factor', 3.0, float,
                      'minimum contrast for an ESR to not be considered noise (suggest 3.0-4.0)'),
            Parameter('to_plot', 'fwhm', ['fwhm', 'contrast'], 'choose to plot fwhm or contrast in 1D sweep')
        ]),
        Parameter('tracking_settings', [Parameter('track_focus', 'optimize_z', ['optimize_z', 'autofocus', 'None'],
                                                  'choose the method for tracking (optimize_z is recommended)'),
                                        Parameter('track_focus_every_N', 5, int, 'track every N points'),
                                        Parameter('track_to_nv', True, bool,
                                                  'check to use find_nv to track to the NV'),
                                        Parameter('track_to_nv_every_N', 1, int, 'track every N points'),
                                        Parameter('track_frequency', True, bool,
                                                  'keep track of the frequency and set it to the central frequency of the next ESR scan (recommended)'),
                                        Parameter('track_frequency_every_N', 1, int, 'track every N points')]),
        Parameter('optimize_z_settings', [Parameter('sweep_range', 0.5, float, 'z voltage range for optimizing scan (suggest 0.6)'),
                                          Parameter('num_points', 36, int, 'number of z points to scan (suggest 41)'),
                                          ]),
        Parameter('autofocus_settings', [Parameter('scan_width', 0.6, float, 'z voltage range for optimizing scan (suggest 0.6-0.9)'),
                                         Parameter('num_sweep_points', 6, int,
                                                   'number of values to sweep between min and max voltage (suggest 6-10)'),
                                         ]),
        Parameter('find_nv_settings',
                  [Parameter('sweep_range', 0.37, float, 'voltage range to sweep over to find a max (suggest 0.4)'),
                   Parameter('num_points', 61, int, 'number of points to sweep in the sweep range'),
                   Parameter('nv_size', 21, int,
                             'size of nv in pixels - need to be refined!! needs to be odd number!!!'),
                   Parameter('min_mass', 80, int, 'TEMP: brightness of nv - need to be refined!! (suggest 60-100)'),
                   ])
    ]

    _INSTRUMENTS = {'XServo': MagnetX, 'YServo': MagnetY, 'ZServo': MagnetZ,
                    'mw_gen': R8SMicrowaveGenerator, 'fg': Agilent33120A}

    _SCRIPTS = {'find_nv': FindNV, 'daq_read_counter': Daq_Read_Counter, 'esr': ESR_FastSwp_RnS_FitGuaranteed,
                'autofocus': AutoFocusDAQ, 'optimize_z': optimize, 'rabi': Rabi_N9310A, 'ramsey': Ramsey_N9310A,
                'pdd': PDD_XYreadout, 'wheel':IntensityWheel_Calibration}

    def __init__(self, instruments = None, scripts = None, name = None, settings = None, log_function = None, data_path = None):
        """
        Example of a script that makes use of an instrument
        Args:
            instruments: instruments the script will make use of
            name (optional): name of script, if empty same as class name
            settings (optional): settings for this script, if empty same as default settings
        """

        # call init of superclass
        Script.__init__(self, name, settings=settings, instruments=instruments, scripts=scripts,
                        log_function=log_function, data_path=data_path)

    def _get_instr(self):
        """
        Assigns an instrument relevant to the 1D scan axis.
        """
        if self.settings['scan_axis'] == 'x':
            return self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'y':
            return self.instruments['YServo']['instance']
        elif self.settings['scan_axis'] == 'z':
            return self.instruments['ZServo']['instance']

    def _get_instr_2D(self):
        """
        Assigns an instrument relevant to the 2D scan axis.
        """
        if self.settings['scan_axis'] == 'xy':
            return self.instruments['XServo']['instance'], self.instruments['YServo']['instance']
        elif self.settings['scan_axis'] == 'yx':
            return self.instruments['YServo']['instance'], self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'xz':
            return self.instruments['XServo']['instance'], self.instruments['ZServo']['instance']
        elif self.settings['scan_axis'] == 'zx':
            return self.instruments['ZServo']['instance'], self.instruments['XServo']['instance']
        elif self.settings['scan_axis'] == 'yz':
            return self.instruments['YServo']['instance'], self.instruments['ZServo']['instance']
        elif self.settings['scan_axis'] == 'zy':
            return self.instruments['ZServo']['instance'], self.instruments['YServo']['instance']

    def _get_scan_positions(self, verbose=True):
        '''
        Returns an array of points to go to in the 1D scan.
        '''
        if self.settings['scan_axis'] in ['x', 'y', 'z']:
            min_pos = self.settings['sweep_center'][self.settings['scan_axis']] - 0.5 * self.settings['sweep_span'][
                self.settings['scan_axis']]

            max_pos = self.settings['sweep_center'][self.settings['scan_axis']] + 0.5 * self.settings['sweep_span'][
                self.settings['scan_axis']]
            num_points = self.settings['num_points'][self.settings['scan_axis']]
            scan_pos = [np.linspace(min_pos, max_pos, num_points)]
            if verbose:
                print('-------------Scan Settings---------------')
                print('Scan axis:' + self.settings['scan_axis'])
                print('Values for the primary scan are (in mm):' + self.settings['scan_axis'] + ' = ', scan_pos)

            return scan_pos
        else:
            print('NotImplementedError: multiple dimensional scans not yet implemented')
            NotImplementedError('multiple dimensional scans not yet implemented')

    def _get_scan_positions_2D(self, verbose=True):
        if self.settings['scan_axis'] in ['xy', 'yx', 'xz', 'zx', 'yz', 'zy']:
            # print('for calculating primary positions:')
            # print(self.settings['sweep_center'][self.settings['scan_axis'][0]])
            # print(self.settings['sweep_span'][
            #           self.settings['scan_axis'][0]])
            # print('for calculating secondary positions:')
            # print(self.settings['sweep_center'][self.settings['scan_axis'][1]])
            # print(self.settings['sweep_span'][
            #           self.settings['scan_axis'][1]])

            primary_min_pos = self.settings['sweep_center'][self.settings['scan_axis'][0]] - self.settings['sweep_span'][
                self.settings['scan_axis'][0]]/2.0

            primary_max_pos = self.settings['sweep_center'][self.settings['scan_axis'][0]] +  self.settings['sweep_span'][
                self.settings['scan_axis'][0]]/2.0
            primary_num_points = self.settings['num_points'][self.settings['scan_axis'][0]]
            secondary_min_pos = self.settings['sweep_center'][self.settings['scan_axis'][1]] - self.settings['sweep_span'][self.settings['scan_axis'][1]]/2.0
            secondary_max_pos = self.settings['sweep_center'][self.settings['scan_axis'][1]] + self.settings['sweep_span'][self.settings['scan_axis'][1]]/2.0
            secondary_num_points = self.settings['num_points'][self.settings['scan_axis'][1]]

            primary_scan_pos = np.linspace(primary_min_pos, primary_max_pos, num = primary_num_points)
            secondary_scan_pos = np.linspace(secondary_min_pos, secondary_max_pos, num = secondary_num_points)

            if verbose:
                print('-------------Scan Settings---------------')
                print('Scan axis:' + self.settings['scan_axis'])
                # print('primary_min_pos',primary_min_pos)
                # print('primary_max_pos',primary_max_pos )
                # print('secondary_min_pos',secondary_min_pos )
                # print('secondary_max_pos', secondary_max_pos)
                print('Values for the primary scan are (in mm): ' + self.settings['scan_axis'][0] + ' = ', primary_scan_pos)
                print('Values for the secondary scan are (in mm): ' + self.settings['scan_axis'][1] + ' = ', secondary_scan_pos)
            return primary_scan_pos, secondary_scan_pos

        else:
            print('NotImplementedError: dimension is not right.')
            NotImplementedError('Dimension is not right')

    @staticmethod
    def pts_to_extent(pta, ptb):
        """
        Args:
            pta: point a
            ptb: point b
            roi_mode:   mode how to calculate region of interest
                        corner: pta and ptb are diagonal corners of rectangle.
                        center: pta is center and ptb is extend or rectangle

        Returns: extend of region of interest [xVmin, xVmax, yVmax, yVmin]
        """
        xVmin = pta['x'] - float(ptb['x']) / 2.
        xVmax = pta['x'] + float(ptb['x']) / 2.
        yVmin = pta['y'] - float(ptb['y']) / 2.
        yVmax = pta['y'] + float(ptb['y']) / 2.
        zVmin = pta['z'] - float(ptb['z']) / 2.
        zVmax = pta['z'] + float(ptb['z']) / 2.

        return [xVmin, xVmax, yVmin, yVmax, zVmin, zVmax]

    def meas_fluorescence(self, index = -1):

        # update the tag of the daq_read_counter script
        if index >= 0:
            self.scripts['daq_read_counter'].settings['tag'] = 'daq_read_counter_ind' + str(index)


        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_esr']
        self.scripts['wheel'].run()

        # run daq_read_counter or the relevant script to get fluorescence
        print('==> Start measuring FLUORESCENCE...')
        self.scripts['daq_read_counter'].run()
        time.sleep(self.settings['exp_settings']['fluorescence_time_per_pt'])
        self.scripts['daq_read_counter'].stop()
        data = self.scripts['daq_read_counter'].data['counts']
        print('--> Mean counts = {:0.2f} kcps'.format(np.mean(data)))
        return data

    def do_esr(self, esr_cntr_freq, esr_freq_range, label = None, index = -1, verbose=False):

        # update the tag of the esr script
        if label is not None and index >= 0:
            self.scripts['esr'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['esr'].settings['tag'] = label
        elif index >= 0:
            self.scripts['esr'].settings['tag'] = 'esr_ind' + str(index)

        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_esr']
        self.scripts['wheel'].run()

        # set the right parameters for the ESR scan
        self.scripts['esr'].settings['power_out'] = self.settings['exp_settings']['esr_mw_pwr']
        self.scripts['esr'].settings['esr_avg_min'] = self.settings['exp_settings']['esr_avg_min']
        self.scripts['esr'].settings['esr_avg_max'] = self.settings['exp_settings']['esr_avg_max']
        self.scripts['esr'].settings['freq_start'] = float(esr_cntr_freq)
        self.scripts['esr'].settings['freq_stop'] = float(esr_freq_range)
        self.scripts['esr'].settings['range_type'] = 'center_range'
        self.scripts['esr'].settings['freq_points'] = self.settings['exp_settings']['esr_num_of_pts']
        self.scripts['esr'].settings['ini_stab_time'] = self.settings['exp_settings']['esr_ini_stab_time']
        self.scripts['esr'].settings['time_per_pt'] = self.settings['exp_settings']['esr_time_per_pt']
        self.scripts['esr'].settings['fit_constants']['num_of_peaks'] = self.settings['exp_settings'][
            'esrfit_num_of_peaks']
        self.scripts['esr'].settings['fit_constants']['minimum_counts'] = self.settings['exp_settings'][
            'esrfit_minimum_counts']
        self.scripts['esr'].settings['fit_constants']['contrast_factor'] = self.settings['exp_settings'][
            'esrfit_contrast_factor']
        print('==> Start measuring ESR...')
        self.scripts['esr'].run()
        esr_fit_data = self.scripts['esr'].data['fit_params']
        if verbose:
            print('len(esr_fit_data) =  ', esr_fit_data)

        return esr_fit_data

    def do_rabi(self, mw_freq, label = None, index = -1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['rabi'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['rabi'].settings['tag'] = label
        elif index >= 0:
            self.scripts['rabi'].settings['tag'] = 'rabi_ind' + str(index)

        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_pulse']
        self.scripts['wheel'].run()

        # set the right parameters for the Rabi
        self.scripts['rabi'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        print('==> Start measuring Rabi...')
        self.scripts['rabi'].run()

        if 'fits' in self.scripts['rabi'].data.keys() and self.scripts['rabi'].data['fits'] is not None:
            Rabi_Success = True
            pi_time = self.scripts['rabi'].data['pi_time']
            pi_half_time = self.scripts['rabi'].data['pi_half_time']
            three_pi_half_time = self.scripts['rabi'].data['three_pi_half_time']
            mw_power = self.scripts['rabi'].settings['mw_pulses']['mw_power']
        else:
            Rabi_Success = False
            pi_time = -1.0
            pi_half_time = -1.0
            three_pi_half_time = -1.0
            mw_power = self.scripts['rabi'].settings['mw_pulses']['mw_power']

        return Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time

    def do_ramsey(self, mw_power, mw_freq, pi_half_time, three_pi_half_time, label=None, index=-1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['ramsey'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['ramsey'].settings['tag'] = label
        elif index >= 0:
            self.scripts['ramsey'].settings['tag'] = 'rabi_ind' + str(index)


        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_pulse']
        self.scripts['wheel'].run()

        # set the right parameters for the Ramsey
        self.scripts['ramsey'].settings['mw_pulses']['mw_power'] = float(mw_power)
        self.scripts['ramsey'].settings['mw_pulses']['resonant_freq'] = float(mw_freq)
        self.scripts['ramsey'].settings['mw_pulses']['pi_half_pulse_time'] = float(pi_half_time)
        self.scripts['ramsey'].settings['mw_pulses']['three_pi_half_pulse_time'] = float(three_pi_half_time)

        print('==> Start measuring Ramsey...')
        self.scripts['ramsey'].run()

    def do_pdd(self, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label=None, index=-1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['pdd'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['pdd'].settings['tag'] = label
        elif index >= 0:
            self.scripts['pdd'].settings['tag'] = 'pdd_ind' + str(index)

        # set the intensity wheel to the right position
        self.scripts['wheel'].settings['to-do'] = 'move'
        self.scripts['wheel'].settings['move_to'] = self.settings['exp_settings']['intensity_wheel_pulse']
        self.scripts['wheel'].run()

        # set the right parameters for PDD
        self.scripts['pdd'].settings['mw_pulses']['mw_power'] = float(mw_power)
        self.scripts['pdd'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        self.scripts['pdd'].settings['mw_pulses']['pi_pulse_time'] = float(pi_time)
        self.scripts['pdd'].settings['mw_pulses']['pi_half_pulse_time'] = float(pi_half_time)
        self.scripts['pdd'].settings['mw_pulses']['3pi_half_pulse_time'] = float(three_pi_half_time)

        print('==> Start measuring PDD...')
        self.scripts['pdd'].run()

    def _function(self):
        self.flag_image0_update_plot = True
        # self.settings['exp_to_do']['esr2'] = False # disable doing ESR2 experiment now
        if self.settings['exp_to_do']['Rabi']: # if Rabi is selected, set peak # to be 1.
            self.settings['exp_settings']['esrfit_num_of_peaks'] = 1

        def set_tracking_parameters():
            # set the parameters for all the scripts
            # optimize_z settings
            self.scripts['optimize_z'].update({'optimizing_x': False})
            self.scripts['optimize_z'].update({'optimizing_y': False})
            self.scripts['optimize_z'].update({'optimizing_z': True})
            self.scripts['optimize_z'].settings['sweep_range'].update(
                {'z': self.settings['optimize_z_settings']['sweep_range']})
            self.scripts['optimize_z'].settings['num_points'].update(
                {'z': self.settings['optimize_z_settings']['num_points']})
            # find_nv settings
            self.scripts['find_nv'].update({'center_on_current_location': True})
            self.scripts['find_nv'].update({'sweep_range': self.settings['find_nv_settings']['sweep_range']})
            self.scripts['find_nv'].update({'num_points': self.settings['find_nv_settings']['num_points']})
            self.scripts['find_nv'].update({'nv_size': self.settings['find_nv_settings']['nv_size']})
            self.scripts['find_nv'].update({'min_mass': self.settings['find_nv_settings']['min_mass']})
            # autofocus settings
            self.scripts['autofocus'].update({'scan_width': self.settings['autofocus_settings']['scan_width']})
            self.scripts['autofocus'].update(
                {'num_sweep_points': self.settings['autofocus_settings']['num_sweep_points']})
            self.scripts['autofocus'].scripts['take_image'].settings['num_points'].update({'x': 51})
            self.scripts['autofocus'].scripts['take_image'].settings['num_points'].update({'y': 51})

        def do_tracking(index):

            # update the tag of scripts
            if index >= 0:
                self.scripts['find_nv'].settings['tag'] = 'find_nv_ind' + str(index)
                self.scripts['optimize_z'].settings['tag'] = 'optimize_z_ind' + str(index)
                self.scripts['autofocus'].settings['tag'] = 'autofocus_ind' + str(index)

            # track to the NV if it's time to
            if self.settings['tracking_settings']['track_focus'] != 'None':
                if index > 0 and index % self.settings['tracking_settings']['track_focus_every_N'] == 0:
                    print('==> Do track_focus now:')
                    if self.settings['tracking_settings']['track_focus'] == 'optimize_z':
                        print('    ==> optimize_z starts')
                        self.flag_optimize_z_plot = True
                        self.scripts['optimize_z'].run()
                        self.flag_find_nv_plot = True
                        print('==> find_NV starts (after tracking focus)')
                        self.scripts['find_nv'].run()

                    elif self.settings['tracking_settings']['track_focus'] == 'autofocus':
                        print('    ==> autofocus starts')
                        self.flag_autofocus_plot = True
                        self.scripts['autofocus'].run()

                        print('==> find_NV starts (after tracking focus)')
                        self.flag_find_nv_plot = True
                        self.scripts['find_nv'].run()
            if self.settings['tracking_settings']['track_to_nv']:
                # if index > 0 and index % self.settings['tracking_settings']['track_to_nv_every_N'] == 0 & index % self.settings['tracking_settings']['track_focus_every_N'] != 0:
                if index == 0 or index % self.settings['tracking_settings']['track_to_nv_every_N'] == 0:
                    self.flag_find_nv_plot = True
                    print('==> find_NV starts')
                    self.scripts['find_nv'].run()
            if self.settings['tracking_settings']['track_frequency']:
                if index > 0 and index % self.settings['tracking_settings']['track_frequency_every_N'] == 0:
                    print('==> track_frequency')
                    self.esr_cntr_freq_todo = self.current_esr_cntr_freq
                    self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

        if self.settings['to-do'] == 'read':
            Zservo_position = self.instruments['ZServo']['instance']._get_position()
            Zservo_velocity = self.instruments['ZServo']['instance']._get_velocity()
            self.log('MagnetZ position: ' + str(Zservo_position) + 'mm, velocity = ' + str(Zservo_velocity) + 'mm/s')
            Yservo_position = self.instruments['YServo']['instance']._get_position()
            Yservo_velocity = self.instruments['YServo']['instance']._get_velocity()
            self.log('MagnetY position: ' + str(Yservo_position) + 'mm, velocity = ' + str(Yservo_velocity) + 'mm/s')
            Xservo_position = self.instruments['XServo']['instance']._get_position()
            Xservo_velocity = self.instruments['XServo']['instance']._get_velocity()
            self.log('MagnetX position: ' + str(Xservo_position) + 'mm, velocity = ' + str(Xservo_velocity) + 'mm/s')

        elif self.settings['to-do'] == 'sweepV':
            self.instruments['fg']['instance'].update({'display_on': True})
            self.instruments['fg']['instance'].update({'burst_mod': False})
            self.instruments['fg']['instance'].update({'wave_shape': 'DC'})
            self.instruments['fg']['instance'].update({'offset': 0.0})
            time.sleep(0.1)

            if self.settings['voltages']['min_vol'] < 0:
                V_min = 0
            else:
                V_min = self.settings['voltages']['min_vol']

            voltage_list = np.arange(V_min, self.settings['voltages']['max_vol'], self.settings['voltages']['vol_step']).tolist()

            # The following copied from the magnet sweep codes
            # ESR frequency initial settings (for both 1D and 2D)
            self.current_esr_cntr_freq = self.settings['exp_settings']['esr_cntr_freq']
            self.current_esr2_cntr_freq = self.settings['exp_settings']['esr2_cntr_freq']
            self.esr_cntr_freq_todo = self.current_esr_cntr_freq
            self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

            set_tracking_parameters()

            # forward and backward sweeps
            self.data = {'counts': deque(), 'counts_r': deque(), 'esr_fo': deque(), 'esr_fo_r': deque(),
                         'esr_wo': deque(), 'esr_wo_r': deque(), 'esr_ctrst': deque(), 'esr_ctrst_r': deque(),
                         'esr2_fo': deque(), 'esr2_fo_r': deque(), 'esr2_wo': deque(), 'esr2_wo_r': deque(),
                         'esr2_ctrst': deque(), 'esr2_ctrst_r': deque()}

            self.data['voltages'] = voltage_list
            self.data['voltages_r'] = voltage_list[::-1]
            # self.positions = {'positions': deque()}

            # loop over voltages and call the scripts
            index = 0
            # 1D Forward Sweep
            for pos_index in range(0, len(self.data['voltages'])):
                print('len(self.data[]', len(self.data['voltages']))
                if self._abort:
                    break

                # Set the sweeping TDC001 to be at the initial position
                new_pos = float(self.data['voltages'][pos_index])
                print('============= Start (index = ' + str(index) + ', Forward) =================')
                print('----------- Voltage: {:0.4f} V -----------'.format(new_pos))

                self.instruments['fg']['instance'].update({'offset': new_pos})
                time.sleep(0.1)

                # Do the tracking if it's time to
                print('---------------- Tracking ----------------')
                do_tracking(index)

                # Do the actual measurements
                print('---------------- Experiment ----------------')

                ESR_Success = False
                Rabi_Success = False

                if self.settings['exp_to_do']['fluorescence']:
                    fluor_data = self.meas_fluorescence(index=index)
                    # add to output structures which will be plotted
                    self.data['counts'].append(np.mean(fluor_data))

                if self.settings['exp_to_do']['esr']:
                    esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                               self.settings['exp_settings']['esr_freq_range'], label='esr1',
                                               index=index)

                    if esr_fit_data is None:
                        print('--> No ESR fitting')
                        # add to output structures which will be plotted
                        self.data['esr_fo'].append(0.0)
                        self.data['esr_wo'].append(0.0)
                        self.data['esr_ctrst'].append(0.0)

                    elif len(esr_fit_data) == 4:
                        if esr_fit_data[3] < 0.5e6:
                            self.data['esr_fo'].append(0.0)
                            self.data['esr_wo'].append(0.0)
                            self.data['esr_ctrst'].append(0.0)
                            print(
                                '--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                        else:
                            print(
                                '--> Good, find one ESR peak :). fo = ' + str(
                                    esr_fit_data[2]) + ' Hz, wo = ' + str(
                                    esr_fit_data[3]) + 'Hz')
                            # add to output structures which will be plotted
                            self.data['esr_fo'].append(esr_fit_data[2])
                            self.data['esr_wo'].append(esr_fit_data[3])
                            self.data['esr_ctrst'].append(esr_fit_data[1])
                            # update the ESR center frequency
                            self.current_esr_cntr_freq = esr_fit_data[2]
                            ESR_Success = True

                    elif len(esr_fit_data) == 6:
                        # self.data['esr_fo'].append(0.0)
                        # self.data['esr_wo'].append(0.0)
                        # self.data['esr_ctrst'].append(0.0)
                        # print('--> Find two ESRs peak, but only one is expected. No Fit is recorded.')
                        if esr_fit_data[1] < 0.5e6:
                            self.data['esr_fo'].append(0.0)
                            self.data['esr_wo'].append(0.0)
                            self.data['esr_ctrst'].append(0.0)
                            print(
                                '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                        else:
                            print('--> Find two ESR peaks, only record the first peak info')
                            # add to output structures which will be plotted
                            self.data['esr_fo'].append(esr_fit_data[4])
                            self.data['esr_wo'].append(esr_fit_data[1])
                            self.data['esr_ctrst'].append(esr_fit_data[2])
                            # update the ESR center frequency
                            self.current_esr_cntr_freq = esr_fit_data[4]

                if self.settings['exp_to_do']['Rabi']:

                    if ESR_Success:
                        self.flag_rabi_plot = True
                        print('==> rabi starts')
                        Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time = self.do_rabi(
                            self.current_esr_cntr_freq, label='rabi', index=index)

                    else:
                        Rabi_Success = False
                        print('--> No ESR resonance found. Abort doing Rabi.')

                if self.settings['exp_to_do']['PDD']:
                    if Rabi_Success:
                        self.flag_pdd_plot = True
                        print('==> pdd starts')
                        self.do_pdd(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='pdd',
                                    index=index)

                    else:
                        print('--> No Rabi information found. Abort doing PDD.')

                if self.settings['exp_to_do']['Ramsey']:
                    if Rabi_Success:
                        self.flag_ramsey_plot = True
                        print('==> ramsey starts')
                        self.do_ramsey(mw_power, mw_freq, pi_half_time, three_pi_half_time,
                                       label='ramsey', index=index)
                    else:
                        print('--> No Rabi information found. Abort doing Ramsey.')

                print('==================== Finished (Forward) =======================')
                # record the position
                self.progress = index * 100. / (len(self.data['voltages']) + len(self.data['voltages_r'] ))
                self.updateProgress.emit(int(self.progress))

                index = index + 1
            # the end of the for loop for the forward 1D sweep

            if self.settings['exp_to_do']['backward_sweep']:
                # 1D Backward Sweep
                for pos_r_index in range(0, len(self.data['voltages_r'])):
                    if self._abort:
                        break

                    # Set the sweeping TDC001 to be at the initial position for the backward sweep
                    new_pos = float(self.data['voltages_r'] [pos_r_index])
                    print('============ Start (index = ' + str(index) + ', Backward) =================')
                    print('----------- Voltage: {:0.4f} V -----------'.format(new_pos))
                    self.instruments['fg']['instance'].update({'offset': new_pos})
                    time.sleep(0.1)

                    # Do the tracking if it's time to
                    print('---------------- Tracking ----------------')
                    do_tracking(index)

                    # Do the actual measurements
                    print('---------------- Experiment ----------------')

                    ESR_Success = False
                    Rabi_Success = False

                    if self.settings['exp_to_do']['fluorescence']:
                        fluor_data = self.meas_fluorescence(index=index)
                        # add to output structures which will be plotted
                        self.data['counts_r'].append(np.mean(fluor_data))

                    if self.settings['exp_to_do']['esr']:
                        esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                   self.settings['exp_settings']['esr_freq_range'], label='esr1',
                                                   index=index)

                        if esr_fit_data is None:
                            print('--> No ESR fitting')
                            # add to output structures which will be plotted
                            self.data['esr_fo_r'].append(0.0)
                            self.data['esr_wo_r'].append(0.0)
                            self.data['esr_ctrst_r'].append(0.0)

                        elif len(esr_fit_data) == 4:
                            if esr_fit_data[3] < 0.5e6:
                                self.data['esr_fo_r'].append(0.0)
                                self.data['esr_wo_r'].append(0.0)
                                self.data['esr_ctrst_r'].append(0.0)
                                print(
                                    '--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                            else:
                                print(
                                    '--> Good, find one ESR peak :). fo = ' + str(
                                        esr_fit_data[2]) + ' Hz, wo = ' + str(
                                        esr_fit_data[3]) + 'Hz')
                                # add to output structures which will be plotted
                                self.data['esr_fo_r'].append(esr_fit_data[2])
                                self.data['esr_wo_r'].append(esr_fit_data[3])
                                self.data['esr_ctrst_r'].append(esr_fit_data[1])
                                # update the ESR center frequency
                                self.current_esr_cntr_freq = esr_fit_data[2]
                                ESR_Success = False

                        elif len(esr_fit_data) == 6:
                            # self.data['esr_fo_r'].append(0.0)
                            # self.data['esr_wo_r'].append(0.0)
                            # self.data['esr_ctrst_r'].append(0.0)
                            # print(
                            #     '--> Find two ESR peak, but only one is expected. No Fit is recorded.')
                            if esr_fit_data[1] < 0.5e6:
                                self.data['esr_fo_r'].append(0.0)
                                self.data['esr_wo_r'].append(0.0)
                                self.data['esr_ctrst_r'].append(0.0)
                                print(
                                    '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                            else:
                                print('--> Find two ESR peaks, only record the first peak info')
                                # add to output structures which will be plotted
                                self.data['esr_fo_r'].append(esr_fit_data[4])
                                self.data['esr_wo_r'].append(esr_fit_data[1])
                                self.data['esr_ctrst_r'].append(esr_fit_data[2])
                                # update the ESR center frequency
                                self.current_esr_cntr_freq = esr_fit_data[4]

                    if self.settings['exp_to_do']['Rabi']:

                        if ESR_Success:
                            self.flag_rabi_plot = True
                            print('==> rabi starts')
                            Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time = self.do_rabi(
                                self.current_esr_cntr_freq, label='rabi', index=index)

                        else:
                            Rabi_Success = False
                            print('--> No ESR resonance found. Abort doing Rabi.')

                    if self.settings['exp_to_do']['PDD']:
                        if Rabi_Success:
                            self.flag_pdd_plot = True
                            print('==> pdd starts')
                            self.do_pdd(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='pdd',
                                        index=index)
                        else:
                            print('--> No Rabi information found. Abort doing PDD.')

                    if self.settings['exp_to_do']['Ramsey']:
                        if Rabi_Success:
                            self.flag_ramsey_plot = True
                            print('==> ramsey starts')
                            self.do_ramsey(mw_power, mw_freq, pi_half_time, three_pi_half_time,
                                           label='ramsey', index=index)
                        else:
                            print('--> No Rabi information found. Abort doing Ramsey.')

                    pass

                    print('=================== Finished (Backward) =======================')
                    # record the position
                    self.progress = index * 100. / (len(self.data['voltages']) + len(self.data['voltages_r']))
                    self.updateProgress.emit(int(self.progress))

                    index = index + 1
                # the end of the for loop for the backward 1D sweep

            self.instruments['fg']['instance'].update({'offset': 0.0})
            time.sleep(0.1)
            # clean up data, as in daq_read_counter
            # convert deque object to numpy array or list
            if 'counts' in self.data.keys() is not None:
                # self.data['counts'] = list(self.data['counts'])
                self.data['counts'] = np.asarray(self.data['counts'])
            if 'esr_fo' in self.data.keys() is not None:
                # self.data['esr_fo'] = list(self.data['esr_fo'])
                self.data['esr_fo'] = np.asarray(self.data['esr_fo'])
            if 'esr_wo' in self.data.keys() is not None:
                # self.data['esr_wo'] = list(self.data['esr_wo'])
                self.data['esr_wo'] = np.asarray(self.data['esr_wo'])
            if 'esr_ctrst' in self.data.keys() is not None:
                self.data['esr_ctrst'] = np.asarray(self.data['esr_ctrst'])
            if 'esr2_fo' in self.data.keys() is not None:
                # self.data['esr2_fo'] = list(self.data['esr2_fo'])
                self.data['esr2_fo'] = np.asarray(self.data['esr2_fo'])
            if 'esr2_wo' in self.data.keys() is not None:
                # self.data['esr2_wo'] = list(self.data['esr2_wo'])
                self.data['esr2_wo'] = np.asarray(self.data['esr2_wo'])
            if 'esr2_ctrst' in self.data.keys() is not None:
                self.data['esr2_ctrst'] = np.asarray(self.data['esr2_ctrst'])
            if 'counts_r' in self.data.keys() is not None:
                # self.data['counts'] = list(self.data['counts'])
                self.data['counts_r'] = np.asarray(self.data['counts_r'])
            if 'esr_fo_r' in self.data.keys() is not None:
                # self.data['esr_fo'] = list(self.data['esr_fo'])
                self.data['esr_fo_r'] = np.asarray(self.data['esr_fo_r'])
            if 'esr_wo_r' in self.data.keys() is not None:
                # self.data['esr_wo'] = list(self.data['esr_wo'])
                self.data['esr_wo_r'] = np.asarray(self.data['esr_wo_r'])
            if 'esr_ctrst_r' in self.data.keys() is not None:
                self.data['esr_ctrst_r'] = np.asarray(self.data['esr_ctrst_r'])
            if 'esr2_fo_r' in self.data.keys() is not None:
                # self.data['esr2_fo'] = list(self.data['esr2_fo'])
                self.data['esr2_fo_r'] = np.asarray(self.data['esr2_fo_r'])
            if 'esr2_wo_r' in self.data.keys() is not None:
                # self.data['esr2_wo'] = list(self.data['esr2_wo'])
                self.data['esr2_wo_r'] = np.asarray(self.data['esr2_wo_r'])
            if 'esr2_ctrst_r' in self.data.keys() is not None:
                self.data['esr2_ctrst_r'] = np.asarray(self.data['esr2_ctrst_r'])

        else:
            # initialize the servo positions
            if self.settings['servo_initial']['initialize'] or self.settings['to-do'] == 'initialize':
                print('----------- Servo Initialization -----------')
                print('Xservo:')
                self.instruments['XServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Xservo_min']})
                self.instruments['XServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Xservo_max']})
                self.instruments['XServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['XServo']['instance'].update({'position': self.settings['servo_initial']['Xservo']})
                servo_move = self.instruments['XServo']['instance']._move_servo(self.settings['servo_initial']['Xservo'])
                if not servo_move:
                    print('Xservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True

                print('Yservo:')
                self.instruments['YServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Yservo_min']})
                self.instruments['YServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Yservo_max']})
                self.instruments['YServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['YServo']['instance'].update({'position': self.settings['servo_initial']['Yservo']})
                servo_move = self.instruments['YServo']['instance']._move_servo(self.settings['servo_initial']['Yservo'])
                if not servo_move:
                    print('Yservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True


                print('Zservo:')
                self.instruments['ZServo']['instance'].update({'lower_limit': self.settings['servo_initial']['Zservo_min']})
                self.instruments['ZServo']['instance'].update({'upper_limit': self.settings['servo_initial']['Zservo_max']})
                self.instruments['ZServo']['instance'].update(
                    {'velocity': self.settings['servo_initial']['moving_velocity']})
                # self.instruments['ZServo']['instance'].update({'position': self.settings['servo_initial']['Zservo']})
                servo_move = self.instruments['ZServo']['instance']._move_servo(self.settings['servo_initial']['Zservo'])
                if not servo_move:
                    print('Zservo fails to initialize. Experiment stopped. self._abort = True')
                    self._abort = True

                print('>>>> Servo initialization done')

            if self.settings['to-do'] == 'move':
                print('----------- Servo moving along the scanning axis -----------')
                if self.settings['scan_axis'] in ['x', 'y', 'z']:
                    scan_instr = self._get_instr()
                    print('     ' + self.settings['scan_axis'][0] + ' Servo is moving to ' + self.settings['scan_axis'][
                        0] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][0]]) + 'mm')
                    # scan_instr.update({'position': self.settings['move_to'][self.settings['scan_axis'][0]]})
                    servo_move = scan_instr._move_servo(self.settings['move_to'][self.settings['scan_axis'][0]])
                    if not servo_move:
                        print(self.settings['scan_axis'] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True

                elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz']:
                    scan_instr_pri, scan_instr_sec = self._get_instr_2D()
                    print(self.settings['scan_axis'][1] + ' Servo is moving to ' + self.settings['scan_axis'][
                        1] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][1]]) + 'mm')
                    # scan_instr_sec.update({'position': self.settings['move_to'][self.settings['scan_axis'][1]]})
                    servo_move = scan_instr_sec._move_servo(self.settings['move_to'][self.settings['scan_axis'][1]])
                    if not servo_move:
                        print(self.settings['scan_axis'][1] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True
                    print(self.settings['scan_axis'][0] + ' Servo is moving to ' + self.settings['scan_axis'][
                        0] + ' = ' + str(self.settings['move_to'][self.settings['scan_axis'][0]]) + 'mm')
                    # scan_instr_pri.update({'position': self.settings['move_to'][self.settings['scan_axis'][0]]})
                    servo_move = scan_instr_pri._move_servo(self.settings['move_to'][self.settings['scan_axis'][0]])
                    if not servo_move:
                        print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped. self._abort = True')
                        self._abort = True
                print('>>>> Servo Moving done')

            elif self.settings['to-do'] == 'sweep':
                # ESR frequency initial settings (for both 1D and 2D)
                self.current_esr_cntr_freq = self.settings['exp_settings']['esr_cntr_freq']
                self.current_esr2_cntr_freq = self.settings['exp_settings']['esr2_cntr_freq']
                self.esr_cntr_freq_todo = self.current_esr_cntr_freq
                self.esr2_cntr_freq_todo = self.current_esr2_cntr_freq

                set_tracking_parameters()

                # 1D scan (forward and backward) (note that 2D scan is disabled for now)
                if self.settings['scan_axis'] in ['x', 'y', 'z']:
                    # get the relevant instrument (servo) for controlling the magnet.
                    scan_instr = self._get_instr()
                    # scan_instr._connect()
                    scan_instr.update({'velocity': self.settings['servo_initial']['moving_velocity']})
                    # get positions for the scan.
                    scan_pos = self._get_scan_positions()

                    # forward and backward sweeps
                    self.data = {'counts': deque(), 'counts_r': deque(), 'esr_fo': deque(), 'esr_fo_r': deque(),
                                 'esr_wo': deque(), 'esr_wo_r': deque(), 'esr_ctrst': deque(), 'esr_ctrst_r': deque(),
                                 'esr2_fo': deque(), 'esr2_fo_r': deque(), 'esr2_wo': deque(), 'esr2_wo_r': deque(),
                                 'esr2_ctrst': deque(), 'esr2_ctrst_r': deque()}

                    self.data['positions'] = scan_pos[0]
                    self.data['positions_r'] = scan_pos[0][::-1]
                    self.positions = {'positions': deque()}

                    # loop over scan positions and call the scripts
                    index = 0
                    # 1D Forward Sweep
                    for pos_index in range(0, len(self.data['positions'])):
                        print('len(self.data[]',len(self.data['positions']))
                        if self._abort:
                            break

                        # Set the sweeping TDC001 to be at the initial position
                        new_pos = float(self.data['positions'][pos_index])
                        print('============= Start (index = ' + str(index) + ', Forward) =================')
                        print('----------- Magnet Position: {:0.2f} mm -----------'.format(new_pos))
                        # scan_instr.update({'position': new_pos})  # actually move the instrument to that location.
                        servo_move = scan_instr._move_servo(new_pos)
                        if not servo_move:
                            print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')

                        # If this is not within the safety limits of the instruments, it will not actually move and say so in the log

                        # Do the tracking if it's time to
                        print('---------------- Tracking ----------------')
                        do_tracking(index)

                        # Do the actual measurements
                        print('---------------- Experiment ----------------')

                        ESR_Success = False
                        Rabi_Success = False

                        if self.settings['exp_to_do']['fluorescence']:
                            fluor_data = self.meas_fluorescence(index=index)
                            # add to output structures which will be plotted
                            self.data['counts'].append(np.mean(fluor_data))

                        if self.settings['exp_to_do']['esr']:
                            esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                       self.settings['exp_settings']['esr_freq_range'], label='esr1',
                                                       index=index)

                            if esr_fit_data is None:
                                print('--> No ESR fitting')
                                # add to output structures which will be plotted
                                self.data['esr_fo'].append(0.0)
                                self.data['esr_wo'].append(0.0)
                                self.data['esr_ctrst'].append(0.0)

                            elif len(esr_fit_data) == 4:
                                if esr_fit_data[3] < 0.5e6:
                                    self.data['esr_fo'].append(0.0)
                                    self.data['esr_wo'].append(0.0)
                                    self.data['esr_ctrst'].append(0.0)
                                    print(
                                        '--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print(
                                        '--> Good, find one ESR peak :). fo = ' + str(
                                            esr_fit_data[2]) + ' Hz, wo = ' + str(
                                            esr_fit_data[3]) + 'Hz')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo'].append(esr_fit_data[2])
                                    self.data['esr_wo'].append(esr_fit_data[3])
                                    self.data['esr_ctrst'].append(esr_fit_data[1])
                                    # update the ESR center frequency
                                    self.current_esr_cntr_freq = esr_fit_data[2]
                                    ESR_Success = True

                            elif len(esr_fit_data) == 6:
                                # self.data['esr_fo'].append(0.0)
                                # self.data['esr_wo'].append(0.0)
                                # self.data['esr_ctrst'].append(0.0)
                                # print('--> Find two ESRs peak, but only one is expected. No Fit is recorded.')
                                if esr_fit_data[1] < 0.5e6:
                                    self.data['esr_fo'].append(0.0)
                                    self.data['esr_wo'].append(0.0)
                                    self.data['esr_ctrst'].append(0.0)
                                    print(
                                        '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                else:
                                    print('--> Find two ESR peaks, only record the first peak info')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo'].append(esr_fit_data[4])
                                    self.data['esr_wo'].append(esr_fit_data[1])
                                    self.data['esr_ctrst'].append(esr_fit_data[2])
                                    # update the ESR center frequency
                                    self.current_esr_cntr_freq = esr_fit_data[4]

                        if self.settings['exp_to_do']['Rabi']:

                            if ESR_Success:
                                self.flag_rabi_plot = True
                                print('==> rabi starts')
                                Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time = self.do_rabi(
                                    self.current_esr_cntr_freq, label='rabi', index=index)

                            else:
                                Rabi_Success = False
                                print('--> No ESR resonance found. Abort doing Rabi.')

                        if self.settings['exp_to_do']['PDD']:
                            if Rabi_Success:
                                self.flag_pdd_plot = True
                                print('==> pdd starts')
                                self.do_pdd(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='pdd',
                                            index=index)

                            else:
                                print('--> No Rabi information found. Abort doing PDD.')

                        if self.settings['exp_to_do']['Ramsey']:
                            if Rabi_Success:
                                self.flag_ramsey_plot = True
                                print('==> ramsey starts')
                                self.do_ramsey(mw_power, mw_freq, pi_half_time, three_pi_half_time,
                                               label='ramsey', index=index)
                            else:
                                print('--> No Rabi information found. Abort doing Ramsey.')

                        # if self.settings['exp_to_do']['esr2']:
                        #     esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                        #                                 self.settings['exp_settings']['esr2_freq_range'], label='esr2',
                        #                                 index=index)
                        #     if esr2_fit_data is None:
                        #         print('--> No ESR2 fitting')
                        #         # add to output structures which will be plotted
                        #         self.data['esr2_fo'].append(0.0)
                        #         self.data['esr2_wo'].append(0.0)
                        #         self.data['esr2_ctrst'].append(0.0)
                        #
                        #     elif len(esr2_fit_data) == 4:
                        #         if esr2_fit_data[3] < 0.5e6:
                        #             self.data['esr2_fo'].append(0.0)
                        #             self.data['esr2_wo'].append(0.0)
                        #             self.data['esr2_ctrst'].append(0.0)
                        #             print(
                        #                 '--> Find one ESR2 peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                        #         else:
                        #             print('--> Good, find one ESR2 peak :). fo = ' + str(
                        #                 esr2_fit_data[2]) + ' Hz, wo = ' + str(
                        #                 esr2_fit_data[3]) + 'Hz')
                        #             # add to output structures which will be plotted
                        #             self.data['esr2_fo'].append(esr2_fit_data[2])
                        #             self.data['esr2_wo'].append(esr2_fit_data[3])
                        #             self.data['esr2_ctrst'].append(esr2_fit_data[1])
                        #             # update the ESR2 center frequency
                        #             self.current_esr2_cntr_freq = esr2_fit_data[2]
                        #     elif len(esr2_fit_data) == 6:
                        #         # self.data['esr2_fo'].append(0.0)
                        #         # self.data['esr2_wo'].append(0.0)
                        #         # self.data['esr2_ctrst'].append(0.0)
                        #         # print(
                        #         #     '--> Find two ESR2 peak, but only one is expected. No Fit is recorded.')
                        #         if esr2_fit_data[1] < 0.5e6:
                        #             self.data['esr2_fo'].append(0.0)
                        #             self.data['esr2_wo'].append(0.0)
                        #             self.data['esr2_ctrst'].append(0.0)
                        #             print(
                        #                 '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                        #         else:
                        #             print('--> Find two ESR2 peaks, only record the second peak info')
                        #             # add to output structures which will be plotted
                        #             self.data['esr2_fo'].append(esr2_fit_data[5])
                        #             self.data['esr2_wo'].append(esr2_fit_data[1])
                        #             self.data['esr2_ctrst'].append(esr2_fit_data[3])
                        #
                        #             # update the ESR2 center frequency
                        #             self.current_esr2_cntr_freq = esr2_fit_data[5]

                        print('==================== Finished (Forward) =======================')
                        # record the position
                        self.positions['positions'].append(new_pos)
                        self.progress = index * 100. / (len(self.data['positions']) + len(self.data['positions_r']))
                        self.updateProgress.emit(int(self.progress))

                        index = index + 1
                    # the end of the for loop for the forward 1D sweep

                    if self.settings['exp_to_do']['backward_sweep']:
                        # 1D Backward Sweep
                        for pos_r_index in range(0, len(self.data['positions_r'])):
                            if self._abort:
                                break

                            # Set the sweeping TDC001 to be at the initial position for the backward sweep
                            new_pos = float(self.data['positions_r'][pos_r_index])
                            print('============ Start (index = ' + str(index) + ', Backward) =================')
                            print('----------- Magnet Position: {:0.2f} mm -----------'.format(new_pos))
                            # scan_instr.update({'position': new_pos})  # actually move the instrument to that location.
                            servo_move = scan_instr._move_servo(new_pos)
                            if not servo_move:
                                print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')
                            # If this is not within the safety limits of the instruments, it will not actually move and say so in the log

                            # Do the tracking if it's time to
                            print('---------------- Tracking ----------------')
                            do_tracking(index)

                            # Do the actual measurements
                            print('---------------- Experiment ----------------')

                            ESR_Success = False
                            Rabi_Success = False

                            if self.settings['exp_to_do']['fluorescence']:
                                fluor_data = self.meas_fluorescence(index=index)
                                # add to output structures which will be plotted
                                self.data['counts_r'].append(np.mean(fluor_data))

                            if self.settings['exp_to_do']['esr']:
                                esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                                                           self.settings['exp_settings']['esr_freq_range'], label='esr1',
                                                           index=index)

                                if esr_fit_data is None:
                                    print('--> No ESR fitting')
                                    # add to output structures which will be plotted
                                    self.data['esr_fo_r'].append(0.0)
                                    self.data['esr_wo_r'].append(0.0)
                                    self.data['esr_ctrst_r'].append(0.0)

                                elif len(esr_fit_data) == 4:
                                    if esr_fit_data[3] < 0.5e6:
                                        self.data['esr_fo_r'].append(0.0)
                                        self.data['esr_wo_r'].append(0.0)
                                        self.data['esr_ctrst_r'].append(0.0)
                                        print(
                                            '--> Find one ESR peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print(
                                            '--> Good, find one ESR peak :). fo = ' + str(
                                                esr_fit_data[2]) + ' Hz, wo = ' + str(
                                                esr_fit_data[3]) + 'Hz')
                                        # add to output structures which will be plotted
                                        self.data['esr_fo_r'].append(esr_fit_data[2])
                                        self.data['esr_wo_r'].append(esr_fit_data[3])
                                        self.data['esr_ctrst_r'].append(esr_fit_data[1])
                                        # update the ESR center frequency
                                        self.current_esr_cntr_freq = esr_fit_data[2]
                                        ESR_Success = False

                                elif len(esr_fit_data) == 6:
                                    # self.data['esr_fo_r'].append(0.0)
                                    # self.data['esr_wo_r'].append(0.0)
                                    # self.data['esr_ctrst_r'].append(0.0)
                                    # print(
                                    #     '--> Find two ESR peak, but only one is expected. No Fit is recorded.')
                                    if esr_fit_data[1] < 0.5e6:
                                        self.data['esr_fo_r'].append(0.0)
                                        self.data['esr_wo_r'].append(0.0)
                                        self.data['esr_ctrst_r'].append(0.0)
                                        print(
                                            '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                                    else:
                                        print('--> Find two ESR peaks, only record the first peak info')
                                        # add to output structures which will be plotted
                                        self.data['esr_fo_r'].append(esr_fit_data[4])
                                        self.data['esr_wo_r'].append(esr_fit_data[1])
                                        self.data['esr_ctrst_r'].append(esr_fit_data[2])
                                        # update the ESR center frequency
                                        self.current_esr_cntr_freq = esr_fit_data[4]

                            if self.settings['exp_to_do']['Rabi']:

                                if ESR_Success:
                                    self.flag_rabi_plot = True
                                    print('==> rabi starts')
                                    Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time = self.do_rabi(
                                        self.current_esr_cntr_freq, label='rabi', index=index)

                                else:
                                    Rabi_Success = False
                                    print('--> No ESR resonance found. Abort doing Rabi.')

                            if self.settings['exp_to_do']['PDD']:
                                if Rabi_Success:
                                    self.flag_pdd_plot = True
                                    print('==> pdd starts')
                                    self.do_pdd(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='pdd',
                                                index=index)
                                else:
                                    print('--> No Rabi information found. Abort doing PDD.')

                            if self.settings['exp_to_do']['Ramsey']:
                                if Rabi_Success:
                                    self.flag_ramsey_plot = True
                                    print('==> ramsey starts')
                                    self.do_ramsey(mw_power, mw_freq, pi_half_time, three_pi_half_time,
                                                   label='ramsey', index=index)
                                else:
                                    print('--> No Rabi information found. Abort doing Ramsey.')

                            pass


                            # if self.settings['exp_to_do']['esr2']:
                            #     esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                            #                                 self.settings['exp_settings']['esr2_freq_range'], label='esr2',
                            #                                 index=index)
                            #     if esr2_fit_data is None:
                            #         print('--> No ESR2 fitting')
                            #         # add to output structures which will be plotted
                            #         self.data['esr2_fo_r'].append(0.0)
                            #         self.data['esr2_wo_r'].append(0.0)
                            #         self.data['esr2_ctrst_r'].append(0.0)
                            #
                            #     elif len(esr2_fit_data) == 4:
                            #         if esr2_fit_data[3] < 0.5e6:
                            #             self.data['esr2_fo_r'].append(0.0)
                            #             self.data['esr2_wo_r'].append(0.0)
                            #             self.data['esr2_ctrst_r'].append(0.0)
                            #             print(
                            #                 '--> Find one ESR2 peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                            #         else:
                            #             print('--> Good, find one ESR2 peak :). fo = ' + str(
                            #                 esr2_fit_data[2]) + ' Hz, wo = ' + str(
                            #                 esr2_fit_data[3]) + 'Hz')
                            #             # add to output structures which will be plotted
                            #             self.data['esr2_fo_r'].append(esr2_fit_data[2])
                            #             self.data['esr2_wo_r'].append(esr2_fit_data[3])
                            #             self.data['esr2_ctrst_r'].append(esr2_fit_data[1])
                            #             # update the ESR2 center frequency
                            #             self.current_esr2_cntr_freq = esr2_fit_data[2]
                            #     elif len(esr2_fit_data) == 6:
                            #         # self.data['esr2_fo_r'].append(0.0)
                            #         # self.data['esr2_wo_r'].append(0.0)
                            #         # self.data['esr2_ctrst_r'].append(0.0)
                            #         # print(
                            #         #     '--> Find two ESR2 peak, but only one is expected. No Fit is recorded.')
                            #
                            #         if esr2_fit_data[1] < 0.5e6:
                            #             self.data['esr2_fo_r'].append(0.0)
                            #             self.data['esr2_wo_r'].append(0.0)
                            #             self.data['esr2_ctrst_r'].append(0.0)
                            #             print(
                            #                 '--> Find two ESRs peak, but it is not good fit because the width is < 0.5 MHz which is impossible')
                            #         else:
                            #             print('--> Find two ESR2 peaks, only record the first peak info')
                            #             # add to output structures which will be plotted
                            #             self.data['esr2_fo_r'].append(esr2_fit_data[5])
                            #             self.data['esr2_wo_r'].append(esr2_fit_data[1])
                            #             self.data['esr2_ctrst_r'].append(esr2_fit_data[3])
                            #             # update the ESR2 center frequency
                            #             self.current_esr2_cntr_freq = esr2_fit_data[5]

                            print('=================== Finished (Backward) =======================')
                            # record the position
                            self.positions['positions'].append(new_pos)
                            self.progress = index * 100. / (len(self.data['positions']) + len(self.data['positions_r']))
                            self.updateProgress.emit(int(self.progress))

                            index = index + 1

                            pass
                        # the end of the for loop for the backward 1D sweep

                    # clean up data, as in daq_read_counter
                    # convert deque object to numpy array or list
                    if 'counts' in self.data.keys() is not None:
                        # self.data['counts'] = list(self.data['counts'])
                        self.data['counts'] = np.asarray(self.data['counts'])
                    if 'esr_fo' in self.data.keys() is not None:
                        # self.data['esr_fo'] = list(self.data['esr_fo'])
                        self.data['esr_fo'] = np.asarray(self.data['esr_fo'])
                    if 'esr_wo' in self.data.keys() is not None:
                        # self.data['esr_wo'] = list(self.data['esr_wo'])
                        self.data['esr_wo'] = np.asarray(self.data['esr_wo'])
                    if 'esr_ctrst' in self.data.keys() is not None:
                        self.data['esr_ctrst'] = np.asarray(self.data['esr_ctrst'])
                    if 'esr2_fo' in self.data.keys() is not None:
                        # self.data['esr2_fo'] = list(self.data['esr2_fo'])
                        self.data['esr2_fo'] = np.asarray(self.data['esr2_fo'])
                    if 'esr2_wo' in self.data.keys() is not None:
                        # self.data['esr2_wo'] = list(self.data['esr2_wo'])
                        self.data['esr2_wo'] = np.asarray(self.data['esr2_wo'])
                    if 'esr2_ctrst' in self.data.keys() is not None:
                        self.data['esr2_ctrst'] = np.asarray(self.data['esr2_ctrst'])
                    if 'counts_r' in self.data.keys() is not None:
                        # self.data['counts'] = list(self.data['counts'])
                        self.data['counts_r'] = np.asarray(self.data['counts_r'])
                    if 'esr_fo_r' in self.data.keys() is not None:
                        # self.data['esr_fo'] = list(self.data['esr_fo'])
                        self.data['esr_fo_r'] = np.asarray(self.data['esr_fo_r'])
                    if 'esr_wo_r' in self.data.keys() is not None:
                        # self.data['esr_wo'] = list(self.data['esr_wo'])
                        self.data['esr_wo_r'] = np.asarray(self.data['esr_wo_r'])
                    if 'esr_ctrst_r' in self.data.keys() is not None:
                        self.data['esr_ctrst_r'] = np.asarray(self.data['esr_ctrst_r'])
                    if 'esr2_fo_r' in self.data.keys() is not None:
                        # self.data['esr2_fo'] = list(self.data['esr2_fo'])
                        self.data['esr2_fo_r'] = np.asarray(self.data['esr2_fo_r'])
                    if 'esr2_wo_r' in self.data.keys() is not None:
                        # self.data['esr2_wo'] = list(self.data['esr2_wo'])
                        self.data['esr2_wo_r'] = np.asarray(self.data['esr2_wo_r'])
                    if 'esr2_ctrst_r' in self.data.keys() is not None:
                        self.data['esr2_ctrst_r'] = np.asarray(self.data['esr2_ctrst_r'])
                # 2D scan (forward and backward) (disabled for now...)
                # elif self.settings['scan_axis'] in ['xy', 'yx', 'yz', 'zy', 'zx', 'xz']:
                #
                #     # get the relevant instrument for controlling the magnet.
                #     scan_instr_pri, scan_instr_sec = self._get_instr_2D()
                #     scan_instr_pri.update({'velocity': self.settings['servo_initial']['moving_velocity']})
                #     scan_instr_sec.update({'velocity': self.settings['servo_initial']['moving_velocity']})
                #
                #     # get the positions for the scan.
                #     scan_pos_pri, scan_pos_sec = self._get_scan_positions_2D()
                #     scan_pos_pri_r = scan_pos_pri[::-1]
                #
                #     # [self.xVmin, self.xVmax, self.yVmin, self.yVmax, self.zVmin, self.zVmax] = self.pts_to_extent(
                #     #     self.settings['sweep_center'], self.settings['sweep_span'])
                #
                #     # Data Structure
                #     # self.data = {'bounds': [scan_pos_pri[0], scan_pos_pri[-1], scan_pos_sec[0], scan_pos_sec[-1],],
                #     self.data = {'bounds': [scan_pos_pri[0], scan_pos_pri[-1], scan_pos_sec[-1], scan_pos_sec[0], ],
                #                  'scan_pos_pri': scan_pos_pri, 'scan_pos_sec': scan_pos_sec,
                #                  'counts': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'counts_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_fo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_fo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_wo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_wo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_ctrst': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr_ctrst_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_fo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_fo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_wo': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_wo_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_ctrst': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri)))),
                #                  'esr2_ctrst_r': np.zeros((int(len(scan_pos_sec)), int(len(scan_pos_pri))))}
                #
                #     print('bounds:', self.data['bounds'])
                #
                #     # 2D forward and backward sweeps
                #     index = 0
                #     for pos_sec_index in range(0, len(scan_pos_sec)):
                #         if self._abort:
                #             break
                #
                #         # Set the sweeping TDC001 to be at the initial position
                #         new_pos_sec = float(scan_pos_sec[pos_sec_index])
                #         print('★★★★★★★★★★★★★  Start (index = ' + str(index) + ', Secondary) ★★★★★★★★★★★★★★')
                #         print('------ Moving to Secondary Position: ' + self.settings['scan_axis'][
                #             1] + ' = {:0.2f} mm --------'.format(new_pos_sec))
                #         # scan_instr_sec.update({'position': new_pos_sec})  # actually move the instrument to that location.
                #         servo_move = scan_instr_sec._move_servo(new_pos_sec)
                #         if not servo_move:
                #             print(self.settings['scan_axis'][1] + 'servo fails to move. Experiment stopped.')
                #         # If this is not within the safety limits of the instruments, it will not actually move and say so in the log
                #
                #         # Forward Primary loop
                #         for pos_pri_index in range(0, len(scan_pos_pri)):
                #             if self._abort:
                #                 break
                #             new_pos_pri = float(scan_pos_pri[pos_pri_index])
                #             print('============= Start (index = ' + str(index) + ', Primary, Forward) ============')
                #             print('------ Moving to Primary Position: ' + self.settings['scan_axis'][
                #                 0] + ' = {:0.2f} mm --------'.format(new_pos_pri))
                #             # scan_instr_pri.update({'position': new_pos_pri})  # actually move the instrument to that location.
                #             servo_move = scan_instr_pri._move_servo(new_pos_pri)
                #             if not servo_move:
                #                 print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')
                #
                #             print('---------------- Tracking ----------------')
                #             do_tracking(index)
                #
                #             # Do the actual measurements
                #             print('---------------- Experiment ----------------')
                #             if self.settings['exp_to_do']['fluorescence']:
                #                 fluor_data = self.meas_fluorescence(index=index)
                #                 # add to output structures which will be plotted
                #                 # self.data['counts'].append(np.mean(fluor_data))
                #                 self.data['counts'][pos_sec_index][pos_pri_index] = np.mean(fluor_data)
                #             if self.settings['exp_to_do']['esr']:
                #                 esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                #                                            self.settings['exp_settings']['esr_freq_range'],
                #                                            label='esr1', index=index)
                #
                #                 if esr_fit_data is None:
                #                     print('--> No ESR fitting :(')
                #                     # self.data['esr_fo'].append(0.0)
                #                     # self.data['esr_wo'].append(0.0)
                #
                #                 elif len(esr_fit_data) == 4:
                #                     if esr_fit_data[3] < 0.5e6:
                #                         # self.data['esr_fo'].append(0.0)
                #                         # self.data['esr_wo'].append(0.0)
                #                         print(
                #                             '--> Find one ESR peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print(
                #                             '--> Good, find one ESR peak :). fo = ' + str(
                #                                 esr_fit_data[2]) + ' Hz, wo = ' + str(
                #                                 esr_fit_data[3]) + 'Hz')
                #                         # add to output structures which will be plotted
                #                         # self.data['esr_fo'].append(esr_fit_data[2])
                #                         # self.data['esr_wo'].append(esr_fit_data[3])
                #                         self.data['esr_fo'][pos_sec_index][pos_pri_index] = esr_fit_data[2]
                #                         self.data['esr_wo'][pos_sec_index][pos_pri_index] = esr_fit_data[3]
                #                         self.data['esr_ctrst'][pos_sec_index][pos_pri_index] = esr_fit_data[1]
                #
                #                         # update the ESR center frequency
                #                         self.current_esr_cntr_freq = esr_fit_data[2]
                #
                #                 elif len(esr_fit_data) == 6:
                #                     # print(
                #                     #     '--> Find two ESR peaks, but only one is expected. No Fit is recorded.')
                #                     if esr_fit_data[1] < 0.5e6:
                #
                #                         print(
                #                             '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Find two ESR peaks, only record the first peak info')
                #                         # add to output structures which will be plotted
                #
                #                         self.data['esr_fo'][pos_sec_index][pos_pri_index] = esr_fit_data[4]
                #                         self.data['esr_wo'][pos_sec_index][pos_pri_index] = esr_fit_data[1]
                #                         self.data['esr_ctrst'][pos_sec_index][pos_pri_index] = esr_fit_data[2]
                #                         # update the ESR center frequency
                #                         self.current_esr_cntr_freq = esr_fit_data[4]
                #             if self.settings['exp_to_do']['esr2']:
                #                 esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                #                                             self.settings['exp_settings']['esr2_freq_range'],
                #                                             label='esr2', index=index)
                #                 if esr2_fit_data is None:
                #                     print('--> No ESR2 fitting :(')
                #                     # self.data['esr2_fo'].append(0.0)
                #                     # self.data['esr2_wo'].append(0.0)
                #                 elif len(esr2_fit_data) == 4:
                #                     if esr2_fit_data[3] < 0.5e6:
                #                         print(
                #                             '--> Find one ESR2 peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Good, find one ESR2 peak :). fo = ' + str(
                #                             esr2_fit_data[2]) + ' Hz, wo = ' + str(
                #                             esr2_fit_data[3]) + 'Hz')
                #                         # add to output structures which will be plotted
                #
                #                         self.data['esr2_fo'][pos_sec_index][pos_pri_index] = esr2_fit_data[2]
                #                         self.data['esr2_wo'][pos_sec_index][pos_pri_index] = esr2_fit_data[3]
                #                         self.data['esr2_ctrst'][pos_sec_index][pos_pri_index] = esr2_fit_data[1]
                #                         # update the ESR2 center frequency
                #                         self.current_esr2_cntr_freq = esr2_fit_data[2]
                #                 elif len(esr2_fit_data) == 6:
                #                     # print(
                #                     #     '--> Find two ESR2 peaks, but only one is expected. No Fit is recorded.')
                #                     if esr2_fit_data[1] < 0.5e6:
                #
                #                         print(
                #                             '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Find two ESR2 peaks, only record the first peak info')
                #                         # add to output structures which will be plotted
                #
                #                         self.data['esr2_fo'][pos_sec_index][pos_pri_index] = esr2_fit_data[5]
                #                         self.data['esr2_wo'][pos_sec_index][pos_pri_index] = esr2_fit_data[1]
                #                         self.data['esr2_ctrst'][pos_sec_index][pos_pri_index] = esr2_fit_data[3]
                #                         # update the ESR2 center frequency
                #                         self.current_esr2_cntr_freq = esr2_fit_data[5]
                #
                #             print('==================== Finished (Forward) =======================')
                #             self.progress = index * 100. / (len(scan_pos_pri) * len(scan_pos_sec) * 2)
                #             self.updateProgress.emit(int(self.progress))
                #             index = index + 1
                #         # the end of the forward primary loop
                #         pass
                #
                #         # Backward Primary loop
                #         for pos_pri_r_index in range(0, len(scan_pos_pri_r)):
                #             if self._abort:
                #                 break
                #             new_pos_pri_r = float(scan_pos_pri_r[pos_pri_r_index])
                #             print('============= Start (index = ' + str(index) + ', Primary, Backward) ============')
                #             print('------ Moving to Primary Position: ' + self.settings['scan_axis'][
                #                 0] + ' = {:0.2f} mm --------'.format(new_pos_pri_r))
                #             # scan_instr_pri.update({'position': new_pos_pri_r})  # actually move the instrument to that location.
                #             servo_move = scan_instr_pri._move_servo(new_pos_pri_r)
                #             if not servo_move:
                #                 print(self.settings['scan_axis'][0] + 'servo fails to move. Experiment stopped.')
                #
                #             print('---------------- Tracking ----------------')
                #             do_tracking(index)
                #
                #             # Do the actual measurements
                #             print('---------------- Experiment ----------------')
                #             if self.settings['exp_to_do']['fluorescence']:
                #                 fluor_data = self.meas_fluorescence(index=index)
                #                 # add to output structures which will be plotted
                #                 # self.data['counts'].append(np.mean(fluor_data))
                #                 self.data['counts_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = np.mean(fluor_data)
                #             if self.settings['exp_to_do']['esr']:
                #                 esr_fit_data = self.do_esr(self.esr_cntr_freq_todo,
                #                                            self.settings['exp_settings']['esr_freq_range'],
                #                                            label='esr1', index=index)
                #
                #                 if esr_fit_data is None:
                #                     print('--> No ESR fitting :(')
                #                     # self.data['esr_fo'].append(0.0)
                #                     # self.data['esr_wo'].append(0.0)
                #
                #                 elif len(esr_fit_data) == 4:
                #                     if esr_fit_data[3] < 0.5e6:
                #                         # self.data['esr_fo'].append(0.0)
                #                         # self.data['esr_wo'].append(0.0)
                #                         print(
                #                             '--> Find one ESR peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print(
                #                             '--> Good, find one ESR peak :). fo = ' + str(
                #                                 esr_fit_data[2]) + ' Hz, wo = ' + str(
                #                                 esr_fit_data[3]) + 'Hz')
                #                         # add to output structures which will be plotted
                #                         # self.data['esr_fo'].append(esr_fit_data[2])
                #                         # self.data['esr_wo'].append(esr_fit_data[3])
                #                         self.data['esr_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[2]
                #                         self.data['esr_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[3]
                #                         self.data['esr_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[1]
                #
                #                         # update the ESR center frequency
                #                         self.current_esr_cntr_freq = esr_fit_data[2]
                #
                #                 elif len(esr_fit_data) == 6:
                #                     # print(
                #                     #     '--> Find two ESR peaks, but only one is expected. No Fit is recorded.')
                #                     if esr_fit_data[1] < 0.5e6:
                #
                #                         print(
                #                             '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Find two ESR peaks, only record the first peak info')
                #                         # add to output structures which will be plotted
                #
                #                         self.data['esr_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[4]
                #                         self.data['esr_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[1]
                #                         self.data['esr_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr_fit_data[2]
                #                         # update the ESR center frequency
                #                         self.current_esr_cntr_freq = esr_fit_data[4]
                #             if self.settings['exp_to_do']['esr2']:
                #                 esr2_fit_data = self.do_esr(self.esr2_cntr_freq_todo,
                #                                             self.settings['exp_settings']['esr2_freq_range'],
                #                                             label='esr2', index=index)
                #
                #                 if esr2_fit_data is None:
                #                     print('--> No ESR2 fitting :(')
                #                     # self.data['esr2_fo'].append(0.0)
                #                     # self.data['esr2_wo'].append(0.0)
                #                 elif len(esr2_fit_data) == 4:
                #                     if esr2_fit_data[3] < 0.5e6:
                #                         # self.data['esr2_fo'].append(0.0)
                #                         # self.data['esr2_wo'].append(0.0)
                #                         print(
                #                             '--> Find one ESR2 peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Good, find one ESR2 peak :). fo = ' + str(
                #                             esr2_fit_data[2]) + ' Hz, wo = ' + str(
                #                             esr2_fit_data[3]) + 'Hz')
                #                         # add to output structures which will be plotted
                #                         # self.data['esr2_fo'].append(esr2_fit_data[2])
                #                         # self.data['esr2_wo'].append(esr2_fit_data[3])
                #                         self.data['esr2_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             2]
                #                         self.data['esr2_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             3]
                #                         self.data['esr2_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             1]
                #                         # update the ESR2 center frequency
                #                         self.current_esr2_cntr_freq = esr2_fit_data[2]
                #                 elif len(esr2_fit_data) == 6:
                #                     # print(
                #                     #     '--> Find two ESR2 peaks, but only one is expected. No Fit is recorded.')
                #                     if esr2_fit_data[1] < 0.5e6:
                #                         # self.data['esr2_fo'].append(0.0)
                #                         # self.data['esr2_wo'].append(0.0)
                #                         print(
                #                             '--> Find two ESRs peak, but it is not good fit :( because the width is < 0.5 MHz which is impossible')
                #                     else:
                #                         print('--> Find two ESR2 peaks, only record the first peak info')
                #                         # add to output structures which will be plotted
                #                         # self.data['esr2_fo'].append(esr2_fit_data[4])
                #                         # self.data['esr2_wo'].append(esr2_fit_data[1])
                #                         self.data['esr2_fo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             5]
                #                         self.data['esr2_wo_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             1]
                #                         self.data['esr2_ctrst_r'][pos_sec_index][int(-(pos_pri_r_index) - 1)] = \
                #                         esr2_fit_data[
                #                             3]
                #                         # update the ESR2 center frequency
                #                         self.current_esr2_cntr_freq = esr2_fit_data[5]
                #
                #             print('==================== Finished (Backward) =======================')
                #             self.progress = index * 100. / (len(scan_pos_pri) * len(scan_pos_sec) * 2)
                #             self.updateProgress.emit(int(self.progress))
                #             index = index + 1
                #         # the end of the backward primary loop
                #         pass
                #
                #         print('★★★★★★★★★★★★★★★★★★  Finished (Secondary) ★★★★★★★★★★★★★★★★★★')
                #
                #     # the end of the 2D sweep
                #     pass

    def _plot(self, axes_list, data=None):
        # COMMENT_ME

        if data is None:
            data = self.data
        if self.settings['to-do'] == 'sweepV':
            print('(1D plot of voltage sweep)')
            if self.data['counts'] is not None:
                lbls1 = ['Coil voltage [V]', 'counts [kcps]', 'Fluorescence']
                plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['voltages'], np.array(self.data['counts']),
                                          lbls1, x_r=self.data['voltages_r'], y1_r=np.array(self.data['counts_r']))

            if self.settings['exp_settings']['to_plot'] ==  'contrast': # to plot contrast
                if self.data['esr_fo'] is not None and self.data['esr_ctrst'] is not None:
                    lbls2 = ['Coil voltage [V]', 'f0 [Hz]', 'contrast', 'ESR']
                    plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['voltages'],
                                            np.array(self.data['esr_fo']),
                                            np.array(self.data['esr_ctrst']), lbls2, x_r=self.data['voltages_r'],
                                            y1_r=np.array(self.data['esr_fo_r']), y2_r=np.array(self.data['esr_ctrst_r']))

            else:
                if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                    lbls2 = ['Coil voltage [V]', 'f0 [Hz]', 'wo[Hz]', 'ESR']
                    plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['voltages'],
                                            np.array(self.data['esr_fo']),
                                            np.array(self.data['esr_wo']), lbls2, x_r=self.data['voltages_r'],
                                            y1_r=np.array(self.data['esr_fo_r']), y2_r=np.array(self.data['esr_wo_r']))

        elif self.settings['scan_axis'] in ['x', 'y', 'z'] and self.settings['to-do'] == 'sweep':
            print('(1D plot of magnet position sweep)')
            if self.data['counts'] is not None:
                lbls1 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]',
                         'counts [kcps]', 'Fluorescence']
                plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['positions'], np.array(self.data['counts']),
                                          lbls1, x_r=self.data['positions_r'], y1_r=np.array(self.data['counts_r']))

            if self.settings['exp_settings']['to_plot'] ==  'contrast': # to plot contrast
                if self.data['esr_fo'] is not None and self.data['esr_ctrst'] is not None:
                    lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                             'contrast', 'ESR']
                    plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                            np.array(self.data['esr_fo']),
                                            np.array(self.data['esr_ctrst']), lbls2, x_r=self.data['positions_r'],
                                            y1_r=np.array(self.data['esr_fo_r']), y2_r=np.array(self.data['esr_ctrst_r']))

            else:
                if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                    lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                             'wo[Hz]', 'ESR']
                    plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                            np.array(self.data['esr_fo']),
                                            np.array(self.data['esr_wo']), lbls2, x_r=self.data['positions_r'],
                                            y1_r=np.array(self.data['esr_fo_r']), y2_r=np.array(self.data['esr_wo_r']))

    def _update_plot(self, axes_list):

        # print('_update_plot')

        if self._current_subscript_stage['current_subscript'] is self.scripts['daq_read_counter'] and self.scripts['daq_read_counter'].is_running:
            self.scripts['daq_read_counter']._plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['esr'] and self.scripts['esr'].is_running:
            # print('updating esr plot now')
            self.scripts['esr']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['find_nv'] and self.scripts['find_nv'].is_running:
            if self.flag_find_nv_plot:
                # print('self.flag_find_nv_plot is', self.flag_find_nv_plot)
                self.scripts['find_nv']._plot([axes_list[1]], colorbar=0) # this is to remove colorbar
                self.flag_find_nv_plot = False
            else:
                self.scripts['find_nv']._update_plot([axes_list[1]])
        elif self._current_subscript_stage['current_subscript'] is self.scripts['optimize_z'] and self.scripts['optimize_z'].is_running:
            # print('optimize_z is running, update plot')
            if self.flag_optimize_z_plot:
                self.scripts['optimize_z']._plot([axes_list[1]])
                self.flag_optimize_z_plot = False
            else:
                self.scripts['optimize_z']._update_plot ([axes_list[1]])

        elif self._current_subscript_stage['current_subscript'] is self.scripts['rabi'] and self.scripts['rabi'].is_running:
            # print('rabi is running, update plot')
            if self.flag_rabi_plot:
                self.scripts['rabi']._plot(axes_list)
                self.flag_rabi_plot = False
            else:
                self.scripts['rabi']._update_plot (axes_list)

        elif self._current_subscript_stage['current_subscript'] is self.scripts['pdd'] and self.scripts['pdd'].is_running:
            # print('pdd is running, update plot')
            if self.flag_pdd_plot:
                self.scripts['pdd']._plot(axes_list)
                self.flag_pdd_plot = False
            else:
                self.scripts['pdd']._update_plot (axes_list)

        elif self._current_subscript_stage['current_subscript'] is self.scripts['ramsey'] and self.scripts['ramsey'].is_running:
            # print('ramsey is running, update plot')
            if self.flag_ramsey_plot:
                self.scripts['ramsey']._plot(axes_list)
                self.flag_ramsey_plot = False
            else:
                self.scripts['ramsey']._update_plot (axes_list)


        elif self._current_subscript_stage['current_subscript'] is self.scripts['autofocus'] and self.scripts['autofocus'].is_running:
            # print('autofocus is running, update plot')
            if self.flag_autofocus_plot:
                # print('self.flag_autofocus_plot is', self.flag_autofocus_plot)
                self.scripts['autofocus']._plot([axes_list[0], axes_list[1]], colorbar=0)
                self.flag_autofocus_plot = False
                self.flag_image0_update_plot = False
            else:
                self.scripts['autofocus']._update_plot([axes_list[0], axes_list[1]])
                self.flag_image0_update_plot = False
        else:
            if self.settings['to-do'] == 'sweepV':
                print('(updating 1D plot of coil voltage sweep)')

                if self.data['counts'] is not None:
                    lbls1 = ['Coil voltage [V]', 'counts [kcps]', 'Fluorescence']
                    plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['voltages'], np.array(self.data['counts']),
                                              lbls1, x_r=self.data['voltages_r'], y1_r=np.array(self.data['counts_r']))
                if self.settings['exp_settings']['to_plot'] == 'contrast':  # to plot contrast
                    if self.data['esr_fo'] is not None and self.data['esr_ctrst'] is not None:
                        lbls2 = ['Coil voltage [V]', 'f0 [Hz]', 'contrast', 'ESR']
                        plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['voltages'],
                                                np.array(self.data['esr_fo']),
                                                np.array(self.data['esr_ctrst']), lbls2, x_r=self.data['voltages_r'],
                                                y1_r=np.array(self.data['esr_fo_r']),
                                                y2_r=np.array(self.data['esr_ctrst_r']))

                else: # to plot width
                    if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                        lbls2 = ['Coil voltage [V]', 'f0 [Hz]', 'wo[Hz]', 'ESR']
                        plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['voltages'],
                                                np.array(self.data['esr_fo']),
                                                np.array(self.data['esr_wo']), lbls2, x_r=self.data['voltages_r'],
                                                y1_r=np.array(self.data['esr_fo_r']),
                                                y2_r=np.array(self.data['esr_wo_r']))


            elif self.settings['scan_axis'] in ['x', 'y', 'z'] and self.settings['to-do'] == 'sweep':
                print('(updating 1D plot of magent position sweep)')

                if self.data['counts'] is not None:
                    lbls1 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]',
                             'counts [kcps]', 'Fluorescence']
                    plot_magnet_sweep1D_Fluor([axes_list[0]], self.data['positions'], np.array(self.data['counts']),
                                              lbls1, x_r=self.data['positions_r'], y1_r=np.array(self.data['counts_r']))
                if self.settings['exp_settings']['to_plot'] == 'contrast':  # to plot contrast
                    if self.data['esr_fo'] is not None and self.data['esr_ctrst'] is not None:
                        lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                                 'contrast', 'ESR']
                        plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                                np.array(self.data['esr_fo']),
                                                np.array(self.data['esr_ctrst']), lbls2, x_r=self.data['positions_r'],
                                                y1_r=np.array(self.data['esr_fo_r']),
                                                y2_r=np.array(self.data['esr_ctrst_r']))

                else: # to plot width
                    if self.data['esr_fo'] is not None and self.data['esr_wo'] is not None:
                        lbls2 = ['magnet position ' + self.settings['scan_axis'] + ' [mm]', 'f0 [Hz]',
                                 'wo[Hz]', 'ESR']
                        plot_magnet_sweep1D_ESR([axes_list[2], axes_list[3]], self.data['positions'],
                                                np.array(self.data['esr_fo']),
                                                np.array(self.data['esr_wo']), lbls2, x_r=self.data['positions_r'],
                                                y1_r=np.array(self.data['esr_fo_r']),
                                                y2_r=np.array(self.data['esr_wo_r']))

    def get_axes_layout(self, figure_list):
        """
        returns the axes objects the script needs to plot its data
        this overwrites the default get_axis_layout in PyLabControl.src.core.scripts
        Args:
            figure_list: a list of figure objects
        Returns:
            axes_list: a list of axes objects

        """
        axes_list = []
        if self.settings['scan_axis'] in ['x', 'y', 'z'] or self.settings['to-do'] == 'sweepV':
            if self._plot_refresh is True:
                for fig in figure_list:
                    fig.clf()

                # 3 subplots in total (since ESR2 is not going to be done)
                axes_list.append(figure_list[0].add_subplot(211))  # axes_list[0]
                axes_list.append(figure_list[1].add_subplot(111))  # axes_list[1]
                axes_list.append(figure_list[0].add_subplot(223))  # axes_list[2]
                axes_list.append(figure_list[0].add_subplot(224))  # axes_list[3]

            else:
                axes_list.append(figure_list[0].axes[0])
                axes_list.append(figure_list[1].axes[0])
                axes_list.append(figure_list[0].axes[1])
                axes_list.append(figure_list[0].axes[2])

            return axes_list

class ElectricScan1D(Script):
    """
        ElectricScan1D sweeps the confocal position, in 1D, and does the following experiments:
        (1) Rabi (optional)
        (2) E-Sensing (optional)
        For the optional scripts, set the right parameters in the subscripts.
        Note that only 1D scan is allowed, and only 1 ESR can be done.
        --> Last edited by ZQ 2/24/2020
    """

    _DEFAULT_SETTINGS = [

        Parameter('point_a',
                  [Parameter('x', 0, float, 'x-coordinate [V]'),
                   Parameter('y', 0, float, 'y-coordinate [V]')
                   ]),
        Parameter('point_b',
                  [Parameter('x', 0.2, float, 'x-coordinate [V]'),
                   Parameter('y', 0.2, float, 'y-coordinate [V]')
                   ]),
        Parameter('patch_size', 0.05, [0.005, 0.05, 0.5], 'size of the red circle'),
        Parameter('num_points', 10, int, 'number of x points to scan'),
        Parameter('exp_to_do', [Parameter('Rabi', True, bool, 'measure Rabi at the ESR resonance frequency'),
                                Parameter('eSensing', True, bool,
                                          'measure T2 coherence times using dynamical decoupling')
                                ]),
        Parameter('mw_pulses', [
            Parameter('mw_power_a', -18.0, float, 'microwave power in dBm'),
            Parameter('mw_power_b', -15.0, float, 'microwave power in dBm'),
            Parameter('mw_frequency', 2.87e9, float, 'microwave frequency in Hz')
        ]),

        Parameter('tracking_settings', [Parameter('track_focus', 'optimize_z', ['optimize_z', 'None'],
                                                  'choose the method for tracking (optimize_z is recommended)'),
                                        Parameter('track_focus_every_N', 5, int, 'track every N points')
                                        ]),
        Parameter('DAQ_channels',
                  [Parameter('x_ao_channel', 'ao0', ['ao0', 'ao1', 'ao2', 'ao3'],
                             'Daq channel used for x voltage analog output'),
                   Parameter('y_ao_channel', 'ao1', ['ao0', 'ao1', 'ao2', 'ao3'],
                             'Daq channel used for y voltage analog output')
                   ]),

    ]

    _INSTRUMENTS = {'daq':  NI6353}
    _SCRIPTS = {'optimize_z': optimize, 'rabi': Rabi_N9310A, 'eSensing': eSensing_swpV, 'set_laser': SetLaser}

    def __init__(self, instruments = None, scripts = None, name = None, settings = None, log_function = None, data_path = None):
        """
        Example of a script that makes use of an instrument
        Args:
            instruments: instruments the script will make use of
            name (optional): name of script, if empty same as class name
            settings (optional): settings for this script, if empty same as default settings
        """

        # call init of superclass
        Script.__init__(self, name, settings=settings, instruments=instruments, scripts=scripts,
                        log_function=log_function, data_path=data_path)
        self.daq_out = self.instruments['daq']['instance']

    def _get_scan_params(self, verbose=True):
        '''
        Returns an array of points to go to in the 1D scan.
        '''
        scan_pos_x = np.linspace(self.settings['point_a']['x'], self.settings['point_b']['x'],
                                 self.settings['num_points'])
        scan_pos_y = np.linspace(self.settings['point_a']['y'], self.settings['point_b']['y'],
                                 self.settings['num_points'])
        scan_mw_power = np.linspace(self.settings['mw_pulses']['mw_power_a'], self.settings['mw_pulses']['mw_power_b'],
                                 self.settings['num_points'])

        return scan_pos_x, scan_pos_y, scan_mw_power

    def do_rabi(self, mw_freq, mw_power, label = None, index = -1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['rabi'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['rabi'].settings['tag'] = label
        elif index >= 0:
            self.scripts['rabi'].settings['tag'] = 'rabi_ind' + str(index)

        # set the right parameters for the Rabi
        self.scripts['rabi'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        self.scripts['rabi'].settings['mw_pulses']['mw_power'] = float(mw_power)
        print('==> Start measuring Rabi...')
        self.scripts['rabi'].run()

        if 'fits' in self.scripts['rabi'].data.keys() and self.scripts['rabi'].data['fits'] is not None:
            Rabi_Success = True
            pi_time = self.scripts['rabi'].data['pi_time']
            pi_half_time = self.scripts['rabi'].data['pi_half_time']
            three_pi_half_time = self.scripts['rabi'].data['three_pi_half_time']
            mw_power = self.scripts['rabi'].settings['mw_pulses']['mw_power']
        else:
            Rabi_Success = False
            pi_time = -1.0
            pi_half_time = -1.0
            three_pi_half_time = -1.0
            mw_power = self.scripts['rabi'].settings['mw_pulses']['mw_power']

        return Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time

    def do_eSensing(self, mw_power=None, mw_freq=None, pi_half_time=None, pi_time=None, three_pi_half_time=None,
                    label=None, index=-1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['eSensing'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['eSensing'].settings['tag'] = label
        elif index >= 0:
            self.scripts['eSensing'].settings['tag'] = 'eSensing_ind' + str(index)

        # set the right parameters for PDD
        if mw_power is not None:
            self.scripts['eSensing'].settings['mw_pulses']['mw_power'] = float(mw_power)
        if mw_freq is not None:
            self.scripts['eSensing'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        if pi_time is not None:
            self.scripts['eSensing'].settings['mw_pulses']['pi_pulse_time'] = float(pi_time)
        if pi_half_time is not None:
            self.scripts['eSensing'].settings['mw_pulses']['pi_half_pulse_time'] = float(pi_half_time)
        if three_pi_half_time is not None:
            self.scripts['eSensing'].settings['mw_pulses']['3pi_half_pulse_time'] = float(three_pi_half_time)

        print('==> Start doing eSensing...')
        self.scripts['eSensing'].run()

    def _function(self):

        def set_tracking_parameters():
            # optimize_z settings
            self.scripts['optimize_z'].update({'optimizing_x': False})
            self.scripts['optimize_z'].update({'optimizing_y': False})
            self.scripts['optimize_z'].update({'optimizing_z': True})

        def do_tracking(index):
            # update the tag of scripts
            if index >= 0:
                self.scripts['optimize_z'].settings['tag'] = 'optimize_z_ind' + str(index)

            # track the focus if it's time to
            if self.settings['tracking_settings']['track_focus'] != 'None':
                if index > 0 and index % self.settings['tracking_settings']['track_focus_every_N'] == 0:
                    print('==> Do track_focus now:')
                    if self.settings['tracking_settings']['track_focus'] == 'optimize_z':
                        print('    ==> optimize_z starts')
                        self.flag_optimize_z_plot = True
                        self.scripts['optimize_z'].run()

        # get initial confocal positions
        initial_position = self.daq_out.get_analog_voltages(
            [self.settings['DAQ_channels']['x_ao_channel'], self.settings['DAQ_channels']['y_ao_channel']])
        print('----------- Scanning Starts ------------')
        print('=== initial positions are:')
        print(initial_position)

        mw_frequency = self.settings['mw_pulses']['mw_frequency']

        scan_pos_x, scan_pos_y, scan_mw_power = self._get_scan_params()
        self.data['scan_pos_x'] = scan_pos_x
        self.data['scan_pos_y'] = scan_pos_y
        self.data['scan_mw_power'] = scan_mw_power

        self.scripts['set_laser'].update({'patch_size': self.settings['patch_size']})


        for index in np.arange(self.settings['num_points']):
            if self._abort:
                break
            current_x = scan_pos_x[index]
            current_y = scan_pos_y[index]
            current_mw_power = scan_mw_power[index]

            print('---------------- Moving ----------------')
            self.scripts['set_laser'].settings['point']['x'] = float(current_x)
            self.scripts['set_laser'].settings['point']['y'] = float(current_y)

            self.scripts['set_laser'].run()
            current_position = self.daq_out.get_analog_voltages(
                [self.settings['DAQ_channels']['x_ao_channel'], self.settings['DAQ_channels']['y_ao_channel']])
            print('===== current positions are:')
            print(current_position)

            # Do the tracking if it's time to
            print('---------------- Tracking ----------------')
            set_tracking_parameters()
            do_tracking(index)

            # Do Rabi if selected
            if self.settings['exp_to_do']['Rabi']:
                print('---------------- Rabi ----------------')

                self.flag_rabi_plot = True
                print('==> rabi starts')
                Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time = self.do_rabi(
                    mw_frequency, current_mw_power, label='rabi', index=index)

                # Do E-Sensing if selected
                if self.settings['exp_to_do']['eSensing']:
                    if Rabi_Success:
                        self.flag_eSensing_plot = True
                        print('---------------- E-Sensing ----------------')
                        print('==> eSensing starts')
                        self.do_eSensing(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='eSensing',
                                    index=index)
                    else:
                        print('--> No Rabi information found. Abort doing E-Sensing.')

            # Do E-Sensing if selected
            else:
                if self.settings['exp_to_do']['eSensing']:
                    self.flag_eSensing_plot = True
                    print('---------------- E-Sensing ----------------')
                    print('==> eSensing starts')
                    self.do_eSensing(label='eSensing', index=index)

            self.progress = index * 100. / float(self.settings['num_points'])
            self.updateProgress.emit(int(self.progress))

    def _update_plot(self, axes_list):

        if self._current_subscript_stage['current_subscript'] is self.scripts['optimize_z'] and self.scripts['optimize_z'].is_running:
            # print('optimize_z is running, update plot')
            if self.flag_optimize_z_plot:
                self.scripts['optimize_z']._plot([axes_list[1]])
                self.flag_optimize_z_plot = False
            else:
                self.scripts['optimize_z']._update_plot([axes_list[1]])

        elif self._current_subscript_stage['current_subscript'] is self.scripts['rabi'] and self.scripts['rabi'].is_running:
            # print('rabi is running, update plot')
            if self.flag_rabi_plot:
                self.scripts['rabi']._plot(axes_list)
                self.flag_rabi_plot = False
            else:
                self.scripts['rabi']._update_plot(axes_list)

        elif self._current_subscript_stage['current_subscript'] is self.scripts['eSensing'] and self.scripts['eSensing'].is_running:
            # print('eSensing is running, update plot')
            if self.flag_eSensing_plot:
                self.scripts['eSensing']._plot(axes_list)
                self.flag_eSensing_plot = False
            else:
                self.scripts['eSensing']._update_plot(axes_list)

class ElectricScan2D(Script):
    """
        ElectricScan2D sweeps the confocal position, in 1D or 2D, and does the following experiments:
        (1) Rabi (optional)
        (2) E-Sensing (optional)
        (3) E-Sensing sweep tau (optional)
        For the optional scripts, set the right parameters in the subscripts.

        --> Last edited by ZQ 2/26/2020
    """

    _DEFAULT_SETTINGS = [

        Parameter('point_a',
                  [Parameter('x', 0, float, 'x-coordinate [V]'),
                   Parameter('y', 0, float, 'y-coordinate [V]')
                   ]),
        Parameter('point_b',
                  [Parameter('x', 0.2, float, 'x-coordinate [V]'),
                   Parameter('y', 0.2, float, 'y-coordinate [V]')
                   ]),
        Parameter('num_points', 12, int, 'number of x points to scan in 1D'),
        Parameter('exp_to_do', [Parameter('dimension', '1D', ['1D', '2D'], 'scanning dimension'),
                                Parameter('Rabi', True, bool, 'measure Rabi at the ESR resonance frequency'),
                                Parameter('eSensing', False, bool, 'vary voltage with a fixed tau'),
                                Parameter('eSensing_swp_tau', True, bool,
                                          'vary tau with a fixed voltage (from pulse blaster aux)')
                                ]),
        Parameter('mw_pulses', [
            Parameter('mw_power_a', -18.0, float, 'microwave power in dBm for point a'),
            Parameter('mw_power_b', -15.0, float, 'microwave power in dBm for point b'),
            Parameter('mw_power_2d', -15.0, float, 'microwave power in dBm for 2d scan'),
            Parameter('mw_frequency', 2.87e9, float, 'microwave frequency in Hz')
        ]),

        Parameter('tracking_settings', [Parameter('track_focus', 'optimize_z', ['optimize_z', 'None'],
                                                  'choose the method for tracking (optimize_z is recommended)'),
                                        Parameter('track_focus_every_N', 5, int, 'track every N points')
                                        ]),
        Parameter('DAQ_channels',
                  [Parameter('x_ao_channel', 'ao0', ['ao0', 'ao1', 'ao2', 'ao3'],
                             'Daq channel used for x voltage analog output'),
                   Parameter('y_ao_channel', 'ao1', ['ao0', 'ao1', 'ao2', 'ao3'],
                             'Daq channel used for y voltage analog output')
                   ]),

    ]

    _INSTRUMENTS = {'daq':  NI6353}
    _SCRIPTS = {'optimize_z': optimize, 'rabi': Rabi_N9310A, 'eSensing': eSensing_swpV,
                'eSensing_swp_tau': eSensing_N9310A, 'set_laser': SetLaser}

    def __init__(self, instruments = None, scripts = None, name = None, settings = None, log_function = None, data_path = None):
        """
        Example of a script that makes use of an instrument
        Args:
            instruments: instruments the script will make use of
            name (optional): name of script, if empty same as class name
            settings (optional): settings for this script, if empty same as default settings
        """

        # call init of superclass
        Script.__init__(self, name, settings=settings, instruments=instruments, scripts=scripts,
                        log_function=log_function, data_path=data_path)
        self.daq_out = self.instruments['daq']['instance']

    def _get_scan_params(self, verbose=True):
        '''
        Returns an array of points to go to in the 1D scan / 2D scan
        '''
        scan_pos_x = np.linspace(self.settings['point_a']['x'], self.settings['point_b']['x'],
                                 self.settings['num_points'], endpoint=True)
        scan_pos_y = np.linspace(self.settings['point_a']['y'], self.settings['point_b']['y'],
                                 self.settings['num_points'], endpoint=True)

        if self.settings['exp_to_do']['dimension'] == '1D':
            scan_mw_power = np.linspace(self.settings['mw_pulses']['mw_power_a'],
                                        self.settings['mw_pulses']['mw_power_b'],
                                        self.settings['num_points'], endpoint=True)
            return scan_pos_x, scan_pos_y, scan_mw_power
        else:
            scan_mw_power = np.linspace(self.settings['mw_pulses']['mw_power_2d'],
                                        self.settings['mw_pulses']['mw_power_2d'],
                                        self.settings['num_points'] * self.settings['num_points'], endpoint=True)
            scan_pos_x_2d = []
            scan_pos_y_2d = []
            for pos_y in scan_pos_y:
                for pos_x in scan_pos_x:
                    scan_pos_x_2d.append(pos_x)
                    scan_pos_y_2d.append(pos_y)

            scan_pos_x_2d = np.array(scan_pos_x_2d)
            scan_pos_y_2d = np.array(scan_pos_y_2d)
            return scan_pos_x_2d, scan_pos_y_2d, scan_mw_power

    def do_rabi(self, mw_freq, mw_power, label = None, index = -1, verbose=False):
        # update the tag of rabi script
        if label is not None and index >= 0:
            self.scripts['rabi'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['rabi'].settings['tag'] = label
        elif index >= 0:
            self.scripts['rabi'].settings['tag'] = 'rabi_ind' + str(index)

        # set the right parameters for the Rabi
        self.scripts['rabi'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        self.scripts['rabi'].settings['mw_pulses']['mw_power'] = float(mw_power)
        print('==> Start measuring Rabi...')
        self.scripts['rabi'].run()

        if 'fits' in self.scripts['rabi'].data.keys() and self.scripts['rabi'].data['fits'] is not None:
            Rabi_Success = True
            pi_time = self.scripts['rabi'].data['pi_time']
            pi_half_time = self.scripts['rabi'].data['pi_half_time']
            three_pi_half_time = self.scripts['rabi'].data['three_pi_half_time']
            mw_power = self.scripts['rabi'].settings['mw_pulses']['mw_power']
        else:
            Rabi_Success = False
            pi_time = -1.0
            pi_half_time = -1.0
            three_pi_half_time = -1.0
            mw_power = self.scripts['rabi'].settings['mw_pulses']['mw_power']

        return Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time

    def do_eSensing(self, mw_power=None, mw_freq=None, pi_half_time=None, pi_time=None, three_pi_half_time=None,
                    label=None, index=-1, verbose=False):
        # update the tag of eSensing script
        if label is not None and index >= 0:
            self.scripts['eSensing'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['eSensing'].settings['tag'] = label
        elif index >= 0:
            self.scripts['eSensing'].settings['tag'] = 'eSensing_ind' + str(index)

        # set the right parameters for eSensing
        if mw_power is not None:
            self.scripts['eSensing'].settings['mw_pulses']['mw_power'] = float(mw_power)
        if mw_freq is not None:
            self.scripts['eSensing'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        if pi_time is not None:
            self.scripts['eSensing'].settings['mw_pulses']['pi_pulse_time'] = float(pi_time)
        if pi_half_time is not None:
            self.scripts['eSensing'].settings['mw_pulses']['pi_half_pulse_time'] = float(pi_half_time)
        if three_pi_half_time is not None:
            self.scripts['eSensing'].settings['mw_pulses']['3pi_half_pulse_time'] = float(three_pi_half_time)

        print('==> Start doing eSensing...')
        self.scripts['eSensing'].run()

    def do_eSensing_swp_tau(self, mw_power=None, mw_freq=None, pi_half_time=None, pi_time=None, three_pi_half_time=None,
                    label=None, index=-1, verbose=False):
        # update the tag of eSensing_swp_tau script
        if label is not None and index >= 0:
            self.scripts['eSensing_swp_tau'].settings['tag'] = label + '_ind' + str(index)
        elif label is not None:
            self.scripts['eSensing_swp_tau'].settings['tag'] = label
        elif index >= 0:
            self.scripts['eSensing_swp_tau'].settings['tag'] = 'eSensing_swp_tau_ind' + str(index)

        # set the right parameters for eSensing_swp_tau
        if mw_power is not None:
            self.scripts['eSensing_swp_tau'].settings['mw_pulses']['mw_power'] = float(mw_power)
        if mw_freq is not None:
            self.scripts['eSensing_swp_tau'].settings['mw_pulses']['mw_frequency'] = float(mw_freq)
        if pi_time is not None:
            self.scripts['eSensing_swp_tau'].settings['mw_pulses']['pi_pulse_time'] = float(pi_time)
        if pi_half_time is not None:
            self.scripts['eSensing_swp_tau'].settings['mw_pulses']['pi_half_pulse_time'] = float(pi_half_time)
        if three_pi_half_time is not None:
            self.scripts['eSensing_swp_tau'].settings['mw_pulses']['3pi_half_pulse_time'] = float(three_pi_half_time)

        print('==> Start doing eSensing_swp_tau...')
        self.scripts['eSensing_swp_tau'].run()

    def _function(self):

        def set_tracking_parameters():
            # optimize_z settings
            self.scripts['optimize_z'].update({'optimizing_x': False})
            self.scripts['optimize_z'].update({'optimizing_y': False})
            self.scripts['optimize_z'].update({'optimizing_z': True})

        def do_tracking(index):
            # update the tag of scripts
            if index >= 0:
                self.scripts['optimize_z'].settings['tag'] = 'optimize_z_ind' + str(index)

            # track the focus if it's time to
            if self.settings['tracking_settings']['track_focus'] != 'None':
                if index > 0 and index % self.settings['tracking_settings']['track_focus_every_N'] == 0:
                    print('==> Do track_focus now:')
                    if self.settings['tracking_settings']['track_focus'] == 'optimize_z':
                        print('    ==> optimize_z starts')
                        self.flag_optimize_z_plot = True
                        self.scripts['optimize_z'].run()

        # get initial confocal positions
        initial_position = self.daq_out.get_analog_voltages(
            [self.settings['DAQ_channels']['x_ao_channel'], self.settings['DAQ_channels']['y_ao_channel']])
        print('----------- Scanning Starts ------------')
        print('=== initial positions are:')
        print(initial_position)

        mw_frequency = self.settings['mw_pulses']['mw_frequency']

        scan_pos_x, scan_pos_y, scan_mw_power = self._get_scan_params()
        self.data['scan_pos_x'] = scan_pos_x
        self.data['scan_pos_y'] = scan_pos_y
        self.data['scan_mw_power'] = scan_mw_power

        for index in np.arange(len(scan_pos_x)):
            if self._abort:
                break
            current_x = scan_pos_x[index]
            current_y = scan_pos_y[index]
            current_mw_power = scan_mw_power[index]

            print("-------------- Current: {} out of {}--------------".format(index, len(scan_pos_x)))
            self.scripts['set_laser'].settings['point']['x'] = float(current_x)
            self.scripts['set_laser'].settings['point']['y'] = float(current_y)
            self.scripts['set_laser'].run()

            current_position = self.daq_out.get_analog_voltages(
                [self.settings['DAQ_channels']['x_ao_channel'], self.settings['DAQ_channels']['y_ao_channel']])
            print('===== current positions are:')
            print(current_position)

            # Do the tracking if it's time to
            print('---------------- Tracking ----------------')
            set_tracking_parameters()
            do_tracking(index)

            # Do Rabi if selected
            if self.settings['exp_to_do']['Rabi']:
                print("-------------- Rabi: {} out of {}--------------".format(index, len(scan_pos_x)))

                self.flag_rabi_plot = True
                print('==> rabi starts')
                Rabi_Success, mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time = self.do_rabi(
                    mw_frequency, current_mw_power, label='rabi', index=index)

                # Do E-Sensing if selected
                if self.settings['exp_to_do']['eSensing']:
                    if Rabi_Success:
                        self.flag_eSensing_plot = True
                        print("-------------- E-Sensing: {} out of {}--------------".format(index, len(scan_pos_x)))
                        print('==> eSensing starts (with rabi)')
                        self.do_eSensing(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='eSensing',
                                    index=index)
                    else:
                        print('--> No Rabi information found. Abort doing E-Sensing.')

                if self.settings['exp_to_do']['eSensing_swp_tau']:
                    if Rabi_Success:
                        self.flag_eSensing_swp_tau_plot = True
                        print("------------ E-Sensing_swp_tau: {} out of {}------------".format(index, len(scan_pos_x)))
                        print('==> eSensing_swp_tau starts (with rabi)')
                        self.do_eSensing_swp_tau(mw_power, mw_freq, pi_half_time, pi_time, three_pi_half_time, label='eSensing',
                                    index=index)
                    else:
                        print('--> No Rabi information found. Abort doing E-Sensing_swp_tau.')

            # Do E-Sensing if selected
            else:
                if self.settings['exp_to_do']['eSensing']:
                    self.flag_eSensing_plot = True
                    print("-------------- E-Sensing: {} out of {}--------------".format(index, len(scan_pos_x)))
                    print('==> eSensing starts (no rabi)')
                    self.do_eSensing(label='eSensing', index=index)

                if self.settings['exp_to_do']['eSensing_swp_tau']:
                    self.flag_eSensing_swp_tau_plot = True
                    print("------------ E-Sensing_swp_tau: {} out of {}------------".format(index, len(scan_pos_x)))
                    print('==> eSensing_swp_tau starts (no rabi)')
                    self.do_eSensing_swp_tau(label='eSensing_swp_tau', index=index)

            self.progress = index * 100. / float(len(scan_pos_x))
            self.updateProgress.emit(int(self.progress))

    def _update_plot(self, axes_list):

        if self._current_subscript_stage['current_subscript'] is self.scripts['optimize_z'] and self.scripts['optimize_z'].is_running:
            # print('optimize_z is running, update plot')
            if self.flag_optimize_z_plot:
                self.scripts['optimize_z']._plot([axes_list[1]])
                self.flag_optimize_z_plot = False
            else:
                self.scripts['optimize_z']._update_plot([axes_list[1]])

        elif self._current_subscript_stage['current_subscript'] is self.scripts['rabi'] and self.scripts['rabi'].is_running:
            # print('rabi is running, update plot')
            if self.flag_rabi_plot:
                self.scripts['rabi']._plot(axes_list)
                self.flag_rabi_plot = False
            else:
                self.scripts['rabi']._update_plot(axes_list)

        elif self._current_subscript_stage['current_subscript'] is self.scripts['eSensing'] and self.scripts['eSensing'].is_running:
            # print('eSensing is running, update plot')
            if self.flag_eSensing_plot:
                self.scripts['eSensing']._plot(axes_list)
                self.flag_eSensing_plot = False
            else:
                self.scripts['eSensing']._update_plot(axes_list)

        elif self._current_subscript_stage['current_subscript'] is self.scripts['eSensing_swp_tau'] and self.scripts['eSensing_swp_tau'].is_running:
            # print('eSensing_swp_tau is running, update plot')
            if self.flag_eSensing_swp_tau_plot:
                self.scripts['eSensing_swp_tau']._plot(axes_list)
                self.flag_eSensing_swp_tau_plot = False
            else:
                self.scripts['eSensing_swp_tau']._update_plot(axes_list)

# class CoilSweep1D(Script):
#     """
#             CoilSweep1D sweeps the current in the coil controlled by the function generator, and does the following experiments:
#             (1) NV fluorescence
#             (2) ESR
#             (3) Rabi (optional)
#             (4) Periodic Dynamical Decoupling - PDD (optional)
#             (5) Ramsey (optional)
#             For the optional scripts, set the right parameters in the subscripts.
#             Note that only 1D scan is allowed, and only 1 ESR can be done.
#             --> Last edited by ZQ 11/10/2019
#     """
#
#     _DEFAULT_SETTINGS = [
#         Parameter('to-do', 'sweep', ['sweep'], 'Only sweeping voltage is availale now'),
#         Parameter('voltages',
#                   [Parameter('min_voltage', 0.0, float, 'Minimum votlage [V] in the sweep'),
#                    Parameter('max_voltage', 1.0, float, 'Maximum votlage [V] in the sweep'),
#                    Parameter('voltage_step', 0.1, float, 'Voltage step [V] in the sweep'),
#                    ]),
#         Parameter('exp_to_do', [Parameter('backward_sweep', False, bool, 'whether to do a backward sweep'),
#                                 Parameter('fluorescence', True, bool, 'measure the NV fluorescence'),
#                                 Parameter('esr', True, bool, 'measure the ESR of NV'),
#                                 # Parameter('esr2', False, bool,
#                                 #           'measure the ESR of NV at two different frequencies'), # disabled for this script
#                                 Parameter('Rabi', True, bool, 'measure Rabi at the ESR resonance frequency'),
#                                 Parameter('PDD', True, bool, 'measure T2 coherence times using dynamical decoupling'),
#                                 Parameter('Ramsey', False, bool, 'measure Ramsey')]),
#         Parameter('exp_settings', [
#             Parameter('intensity_wheel_esr', 298, float, 'microwave power for ESR scan'),
#             Parameter('intensity_wheel_pulse', 260, float, 'minimum number of esr averages'),
#             Parameter('fluorescence_time_per_pt', 0.4, float, 'time for fluorescence measurement at each point (s)'),
#             Parameter('esr_mw_pwr', -10, float, 'microwave power for ESR scan'),
#             Parameter('esr_avg_min', 12, int, 'minimum number of esr averages'),
#             Parameter('esr_avg_max', 50, int, 'maximum number of esr averages'),
#             Parameter('esr_cntr_freq', 2.82e9, float, 'center frequency for ESR scan'),
#             Parameter('esr_freq_range', 8.5e7, float, 'frequency range for ESR scan (suggest 6e7 - 9e7)'),
#             Parameter('esr2_cntr_freq', 2.99e9, float, 'center frequency for the second ESR scan'),
#             Parameter('esr2_freq_range', 8.5e7, float, 'frequency range for the second ESR scan(suggest 6e7 - 9e7)'),
#             Parameter('esr_ini_stab_time', 1, int, 'laser power stabilization time (sec)'),
#             Parameter('esr_num_of_pts', 150, int, 'number of frequency points for ESR scan'),
#             Parameter('esr_time_per_pt', 0.02, [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.08, 0.1],
#                       'integration time for each point in the fast ESR scan (suggest 0.02-0.04)'),
#             Parameter('esrfit_num_of_peaks', 1, [-1, 1, 2],
#                       'specify number of peaks for fitting. if not specifying the number of peaks, choose -1'),
#             Parameter('esrfit_minimum_counts', 0.9, float,
#                       'minumum counts for an ESR to not be considered noise (suggest 0.8 - 1.01 if esr is normalized)'),
#             Parameter('esrfit_contrast_factor', 3.0, float,
#                       'minimum contrast for an ESR to not be considered noise (suggest 3.0-4.0)'),
#             Parameter('to_plot', 'fwhm', ['fwhm', 'contrast'], 'choose to plot fwhm or contrast in 1D sweep')
#         ]),
#         Parameter('tracking_settings', [Parameter('track_focus', 'optimize_z', ['optimize_z', 'autofocus', 'None'],
#                                                   'choose the method for tracking (optimize_z is recommended)'),
#                                         Parameter('track_focus_every_N', 5, int, 'track every N points'),
#                                         Parameter('track_to_nv', True, bool,
#                                                   'check to use find_nv to track to the NV'),
#                                         Parameter('track_to_nv_every_N', 1, int, 'track every N points'),
#                                         Parameter('track_frequency', True, bool,
#                                                   'keep track of the frequency and set it to the central frequency of the next ESR scan (recommended)'),
#                                         Parameter('track_frequency_every_N', 1, int, 'track every N points')]),
#         Parameter('optimize_z_settings',
#                   [Parameter('sweep_range', 0.5, float, 'z voltage range for optimizing scan (suggest 0.6)'),
#                    Parameter('num_points', 36, int, 'number of z points to scan (suggest 41)'),
#                    ]),
#         Parameter('autofocus_settings',
#                   [Parameter('scan_width', 0.6, float, 'z voltage range for optimizing scan (suggest 0.6-0.9)'),
#                    Parameter('num_sweep_points', 6, int,
#                              'number of values to sweep between min and max voltage (suggest 6-10)'),
#                    ]),
#         Parameter('find_nv_settings',
#                   [Parameter('sweep_range', 0.37, float, 'voltage range to sweep over to find a max (suggest 0.4)'),
#                    Parameter('num_points', 61, int, 'number of points to sweep in the sweep range'),
#                    Parameter('nv_size', 21, int,
#                              'size of nv in pixels - need to be refined!! needs to be odd number!!!'),
#                    Parameter('min_mass', 80, int, 'TEMP: brightness of nv - need to be refined!! (suggest 60-100)'),
#                    ])
#     ]
#
#     _INSTRUMENTS = {'mw_gen': R8SMicrowaveGenerator, 'fg':Agilent33120A}
#
#     _SCRIPTS = {'find_nv': FindNV, 'daq_read_counter': Daq_Read_Counter, 'esr': ESR_FastSwp_RnS_FitGuaranteed,
#                 'autofocus': AutoFocusDAQ, 'optimize_z': optimize, 'rabi': Rabi_N9310A, 'ramsey': Ramsey_N9310A,
#                 'pdd': PDD_XYreadout, 'wheel': IntensityWheel_Calibration}









